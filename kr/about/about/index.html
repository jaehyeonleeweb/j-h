<!DOCTYPE html>

  
  


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>소개 · j-h</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    
    <!-- 0) 첫 페인트부터 폴백 감추기 (FOUT/FOIT 방지) -->
    <style>
      html:not(.wf-active):not(.wf-inactive) body { visibility: hidden; }
      html.wf-loading body { visibility: hidden; }
      html.wf-active body,
      html.wf-inactive body { visibility: visible; }
      html.wf-active body { animation: fontFadeIn .18s ease-out; }
      @keyframes fontFadeIn { from { opacity: 0 } to { opacity: 1 } }
    </style>

    <!-- 1) 폰트 커넥션 선연결 -->
    <link rel="preconnect" href="https://use.typekit.net" crossorigin>
    <link rel="preconnect" href="https://p.typekit.net" crossorigin>

    <!-- 2) Typekit 로더 -->
    <script>
      (function(d) {
        var config = { kitId: 'efe0obd', scriptTimeout: 3000, async: true },
            h = d.documentElement,
            t = setTimeout(function() {
              h.className = h.className.replace(/\bwf-loading\b/g,"") + " wf-inactive";
            }, config.scriptTimeout),
            tk = d.createElement("script"),
            f = false,
            s = d.getElementsByTagName("script")[0],
            a;
        h.className += " wf-loading";
        tk.src = "https://use.typekit.net/" + config.kitId + ".js";
        tk.async = true;
        tk.onload = tk.onreadystatechange = function() {
          a = this.readyState;
          if (f || (a && a !== "complete" && a !== "loaded")) return;
          f = true; clearTimeout(t);
          try { Typekit.load(config); } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>

    <!-- (선택) 개발 중 편의 -->
    <link rel="stylesheet" href="https://use.typekit.net/efe0obd.css">
    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <!-- 전체 2단 그리드 -->
    <div class="shell">
      <!-- 좌측: 세로 메뉴 -->
      <aside class="site-nav">
        <!-- ✅ 모바일 상단 바 (≤600px에서 보이도록 CSS 제어) -->
        <div class="nav-bar" role="navigation" aria-label="mobile top bar">
          <button class="nav-toggle" id="menu-toggle" aria-expanded="false" aria-controls="nav-menu">menu</button>
          
            <a href="&#x2F;about&#x2F;about&#x2F;" class="lang-toggle">en</a>
          
        </div>

        <!-- ✅ 메인 메뉴: 데스크탑에서 항상 보이고, 모바일에선 토글 대상 -->
        <nav id="nav-menu" aria-label="primary">
          <a href="&#x2F;kr/">all archive</a><br>
          <a href="&#x2F;kr/works/">works</a><br>
          <a href="&#x2F;kr/about/">about</a><br>
          <a href="&#x2F;kr/contact/">contact</a><br>
        
          <!-- ⛔️ 비활성: 링크 대신 span, 클릭 불가, 회색(60%) -->
          <span class="nav-item nav-item--disabled" aria-disabled="true" title="Coming soon">shop</span>
        </nav>

        <!-- ✅ 데스크탑 전용 언어 토글: 메뉴 '아래 한 칸'에 표시 (모바일에선 CSS로 숨김) -->
        <div class="lang-toggle--desktop">
          
            <a href="&#x2F;about&#x2F;about&#x2F;">en</a>
          
        </div>
      </aside>

      <!-- 우측: 콘텐츠 -->
      <main class="site-main">
        


<article class="page-two-col">
  
  <aside class="page-meta">
    <dl class="meta-list">
      
        <dt><h1>document no.:</h1></dt>
        <dd>1</dd>
      
  
      
        <dt><h1>category:</h1></dt>
        <dd>소개</dd>
      
  
      
  
      
  
      
  
      

      

    </dl>
  </aside>

  <div class="page-body page-content">
    
    <h1 class="display-title">
      소개
    </h1>
    <p>이 웹은 <a href="/kr/contact/contact/">나</a>의 온라인 아카이브다.<br />
나는 이 곳에 아카이빙되는 자료들이 서로 그물처럼 얽혀 덤불같은 것을 형성하기를 기대한다.
<br><br>
이 웹의 구조:</p>
<blockquote>
<ol>
<li>이 웹은 이미지와 관련한 실천을 기록한다. 이는 두 층위로 이루어져있다.<sup class="footnote-reference"><a href="#1">1</a></sup>
<ol>
<li>이 웹에는 워크샵<em>workshop</em>을 통해 실천된 아이디어<em>workshop practice</em>가 기록된다.
<ol>
<li>모든 워크샵은 울리포의 ‘잠재문학’<sup class="footnote-reference"><a href="#2">2</a></sup>에서 빌려온 개념 <a href="/kr/thought/th-001/">잠재이미지</a>를 탐구하는 것을 목적으로 한다. 이 실천들의 목적은 제약에 기반한 시도를 통해 이미지가 스스로의 잠재성을 드러내게끔 하는 것이다.</li>
<li>나는 울리포적 입장을 적극 수용하고 있지만 경우에 따라 느슨하게 적용하기도 한다. 나에게 중요한 것은 항상 새로운 것들이다.</li>
</ol>
</li>
<li>이 웹에는 개인적인 작업<em>project</em>(때로는 커미션 작업)의 결과물이—때론 작업 과정과 시행착오가 함께—기록된다.
<ol>
<li>물론 작업 과정에서 모티브의 생성과 발전은 항상 산발적이다.<sup class="footnote-reference"><a href="#3">3</a></sup> 따라서 온전한 기록은 불가능하다. 하지만 생략과 과장을 무릅쓰고서 과정에 대한 기록이 만들어줄 여러 방향의 연결쌍을 상상해본다. 이어진 개념들은 다시 새로운 모티브를 낳을 것이다.
<br><br></li>
</ol>
</li>
</ol>
</li>
<li>이 웹은 실천의 배후에 있던 것들을 기록한다. 이는 세 층위로 이루어져 있다.
<ol>
<li>이 웹에는 실천의 방법<em>method</em>들이 함께 기록된다.
<ol>
<li>모든 실천은 실행의 방법이 존재한다. 그것은 창작자의 의도와 결과물 사이에 존재한다. 방법은 의도와 결과의 무수한 연결쌍을 매개한다.</li>
</ol>
</li>
<li>이 웹에는 나의 생각<em>thought</em>이 함께 기록된다.
<ol>
<li>모든 실천은 몇 가지 사소한 아이디어에서 출발한다. 생각들은 서로 호응하며 몸집을 키워나간다.</li>
</ol>
</li>
<li>이 웹에는 참조<em>glossary</em>가 함께 기록(인용)된다.
<ol>
<li>인용된 정보의 원문을 전후의 맥락과 함께 기록한다. 모든 생각은 뿌리가 있다.</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>실천들은 <em>works</em>에서 확인가능하다.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="/kr/glossary/gl-001/">잠재문학 제1선언문</a> 참고.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="/kr/glossary/gl-002/">개념미술에 관한 문장들</a> 중 11번째 항목 참고. 여기 쓰인 솔 르윗의 문장들은 작업의 모티브(아이디어)와 제작 과정을 분리시켜 전자와 후자를 노골적인 우열관계로 설정하고 있지만 나는 그 분리 자체를 우선시한다. 제작 과정의 우연성이 만들어낼 새로움은 항상 흥미롭다.</p>
</div>


    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const content = document.querySelector('.page-content');
        if (!content) return;
      
        /* ---------------------------------------------
         * 1) 흩어진 각주 아이템을 .footnotes 컨테이너로 래핑
         *    - 대상: .footnote-definition, li[id^="fn"]
         *    - 이미 .footnotes가 있으면 건너뜀
         * --------------------------------------------- */
        let wrap = content.querySelector('.footnotes');
        if (!wrap) {
          const items = Array.from(
            content.querySelectorAll('.footnote-definition, li[id^="fn"]')
          );
          if (items.length) {
            const parent = items[0].parentElement;
            const group = items.filter(el => el.parentElement === parent);
            if (group.length) {
              wrap = document.createElement('div');
              wrap.className = 'footnotes';
              wrap.setAttribute('role', 'doc-endnotes');
              wrap.setAttribute('aria-label', 'Footnotes');
              parent.insertBefore(wrap, group[0]);
              group.forEach(el => wrap.appendChild(el));
            }
          }
        }
      
        /* ---------------------------------------------
         * 2) 각주 본문(p) 내 URL을 <a>로 자동 변환
         *    - 호환: http/https/www
         *    - 말미의 쉼표/마침표/괄호 등은 제외
         * --------------------------------------------- */
        if (wrap) {
          const URL_RE = /((?:https?:\/\/|www\.)[^\s<>()]+?)(?=[\s<>()]|$)/g;
      
          wrap.querySelectorAll('.footnote-definition > p, li[id^="fn"] > p')
            .forEach(p => {
              if (p.dataset.autolinked === '1') return;
              p.innerHTML = p.innerHTML.replace(URL_RE, (m, url) => {
                const href = url.startsWith('http') ? url : `https://${url}`;
                return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
              });
              p.dataset.autolinked = '1';
            });
      
          // 안전: 링크 rel 보정
          wrap.querySelectorAll('a').forEach(a => {
            const rel = (a.getAttribute('rel') || '').split(/\s+/);
            ['noopener','noreferrer'].forEach(tok => { if (!rel.includes(tok)) rel.push(tok); });
            a.setAttribute('rel', rel.join(' ').trim());
          });
        }
      });
      </script>
      
  </div>

</article>


      </main>
    </div>

    <!-- Footer -->
    <footer class="site-footer" role="contentinfo" aria-label="site footer">
      <p class="site-footer__text">
        j-h, jaydashaitch, online archive of jae hyeon lee. ©2025 jaehyeon lee
      </p>
      <p class="site-footer__text--mobile">
        j-h, ©2025 jaehyeon lee
      </p>
    </footer>

    <!-- Hangul span 래핑 스크립트 -->
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const HANGUL_RE = /([\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3]+)/g;
        const SKIP_SELECTOR = 'pre, code, kbd, samp, script, style';
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !HANGUL_RE.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
              let p = node.parentNode;
              while (p && p !== document.body) {
                if (p.matches && p.matches(SKIP_SELECTOR)) return NodeFilter.FILTER_REJECT;
                p = p.parentNode;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        const texts = [];
        let n;
        while (n = walker.nextNode()) texts.push(n);
        for (const text of texts) {
          const span = document.createElement('span');
          span.innerHTML = text.nodeValue.replace(HANGUL_RE, '<span class="han">$1</span>');
          text.parentNode.replaceChild(span, text);
        }
      });
    </script>

    <!-- ✅ Mobile Menu Script -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const btn = document.getElementById("menu-toggle");
        const menu = document.getElementById("nav-menu");
        if (!btn || !menu) return;

        function closeMenu() {
          menu.classList.remove("open");
          btn.setAttribute("aria-expanded", "false");
        }

        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.toggle("open");
          btn.setAttribute("aria-expanded", String(isOpen));
        });

        document.addEventListener("click", (e) => {
          if (!menu.contains(e.target) && !btn.contains(e.target)) closeMenu();
        });

        window.addEventListener("resize", () => {
          if (window.innerWidth > 600) closeMenu();
        });
      });
    </script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (window.__FN_WIRED__) return;
    window.__FN_WIRED__ = true;
  
    /* =========================
       설정값
       ========================= */
    const SCROLL_MS   = 300;   // 부드럽지만 빠르게
    const HL_IN_MS    = 200;   // 페이드 인
    const HL_OUT_MS   = 700;   // 페이드 아웃(느리게)
    const HL_HOLD_MS  = 800;   // 유지 시간(짧게 유지 후 서서히 사라짐)
  
/* =========================
   스크롤 유틸 (컨테이너 대응, quintic S-curve + out-bias)
   ========================= */
   const isScrollable = (el) => {
  if (!el) return false;
  const s = getComputedStyle(el);
  const oy = s.overflowY;
  return (oy === "auto" || oy === "scroll") && el.scrollHeight > el.clientHeight;
};

const getScrollContainer = (el) => {
  let node = el.parentElement;
  while (node && node !== document.body && node !== document.documentElement) {
    if (isScrollable(node)) return node;
    node = node.parentElement;
  }
  return document.scrollingElement || document.documentElement || document.body;
};

/* =========================
   스크롤 애니메이션 (quintic S-curve + out-bias)
   - 부드러운 시작, 끈적한 감속
   ========================= */
const easeInOutSticky = (t) => {
  // Quintic smoothstep (C2 연속, S-curve)
  const t2 = t * t, t3 = t2 * t, t4 = t2 * t2, t5 = t4 * t;
  const base = 6 * t5 - 15 * t4 + 10 * t3; // 기본 S-curve
  const OUT_BIAS = 1.12; // 1.0~1.2 권장 (↑ = 더 끈적한 감속)
  return 1 - Math.pow(1 - base, OUT_BIAS);
};

const scrollToTarget = (container, target, ms = SCROLL_MS, offsetY = 0) =>
  new Promise((resolve) => {
    const containerIsDoc =
      container === document.scrollingElement ||
      container === document.documentElement ||
      container === document.body;

    const containerRect = containerIsDoc
      ? { top: 0 }
      : container.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    const start = containerIsDoc
      ? window.pageYOffset || document.documentElement.scrollTop
      : container.scrollTop;

    const targetY = start + (targetRect.top - containerRect.top) + offsetY;

    if (ms <= 0) {
      if (containerIsDoc) window.scrollTo(0, targetY);
      else container.scrollTop = targetY;
      resolve();
      return;
    }

    const startTime = performance.now();
    const step = (now) => {
      const t = Math.min(1, (now - startTime) / ms);
      const eased = easeInOutSticky(t);
      const y = start + (targetY - start) * eased;

      if (containerIsDoc) window.scrollTo(0, y);
      else container.scrollTop = y;

      if (t < 1) {
        requestAnimationFrame(step);
      } else {
        if (containerIsDoc) window.scrollTo(0, targetY);
        else container.scrollTop = targetY;
        resolve();
      }
    };

    requestAnimationFrame(step);
  });

  
    /* =========================
       하이라이트 (빠른 IN → 유지 → 느린 OUT)
       ========================= */
    const highlight = (host, hold = HL_HOLD_MS) => {
      if (!host) return;
      host.classList.add('fn-hl');  // 초기 상태(투명) + 트랜지션 규칙
      // 다음 프레임에 ON
      requestAnimationFrame(() => {
        host.style.setProperty('--fn-hl-in',  `${HL_IN_MS}ms`);
        host.style.setProperty('--fn-hl-out', `${HL_OUT_MS}ms`);
        host.classList.add('is-on');           // 빠르게 켜짐
        setTimeout(() => {
          host.classList.add('is-fading');     // 느리게 꺼짐
          host.classList.remove('is-on');
          setTimeout(() => host.classList.remove('fn-hl', 'is-fading'), HL_OUT_MS + 30);
        }, hold);
      });
    };
  
    /* =========================
       매핑: 본문 참조 ↔ 각주 블록
       ========================= */
    const allIds = new Set([...document.querySelectorAll('[id]')].map(el => el.id));
    const bodyLinks = [...document.querySelectorAll('.page-content a[href^="#"]')]
      .filter(a => !a.closest('.footnote-definition') && !a.closest('.footnotes'));
  
    const footnoteIds = new Set(
      bodyLinks
        .map(a => (a.getAttribute('href') || '').slice(1))
        .filter(id => id && allIds.has(id))
    );
  
    const getFootnoteBlock = (id) => {
      const el = document.getElementById(id);
      return el
        ? (el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el)
        : null;
    };
  
    const backMap = new Map();
    bodyLinks
      .filter(a => footnoteIds.has((a.getAttribute('href') || '').slice(1)))
      .forEach(a => {
        const id = a.getAttribute('href').slice(1);
        const sup = a.closest('sup[id^="fnref"]') || a.closest('sup');
        const target = sup || a;
        if (!target.id) {
          let base = `fnref-auto-${id}`, i = 1, uid = base;
          while (document.getElementById(uid)) uid = `${base}-${i++}`;
          target.id = uid;
        }
        backMap.set(id, target.id);
      });
  
    /* =========================
       이벤트: 본문 → 각주
       ========================= */
    document.addEventListener('click', async (e) => {
      const ref = e.target.closest('.page-content a[href^="#"]');
      if (!ref || ref.closest('.footnote-definition') || ref.closest('.footnotes')) return;
  
      const hash = ref.getAttribute('href') || '';
      if (!hash.startsWith('#')) return;
  
      const id = hash.slice(1);
      if (!footnoteIds.has(id)) return;
  
      e.preventDefault();
      const fnBlock = getFootnoteBlock(id);
      if (!fnBlock) return;
  
      const container = getScrollContainer(fnBlock);
      await scrollToTarget(container, fnBlock, SCROLL_MS, 0);
      history.pushState(null, '', `#${id}`);
      highlight(fnBlock, HL_HOLD_MS);
    });
  
    /* =========================
       이벤트: 각주 → 본문
       ========================= */
    document.addEventListener('click', async (e) => {
      const a = e.target.closest('a');
      if (a) {
        const href = a.getAttribute('href') || '';
        if (href && !href.startsWith('#')) return; // 외부 링크는 방해하지 않음
      }
  
      let node = e.target.closest('[id]');
      while (node) {
        const id = node.id;
        if (footnoteIds.has(id)) {
          const backId = backMap.get(id);
          if (backId) {
            e.preventDefault();
            const backEl = document.getElementById(backId) || document.querySelector(`a[href="#${id}"]`);
            if (!backEl) return;
            const container = getScrollContainer(backEl);
            await scrollToTarget(container, backEl, SCROLL_MS, 0);
            history.pushState(null, '', `#${backId}`);
            highlight(backEl, HL_HOLD_MS);
          }
          return;
        }
        node = node.parentElement;
      }
    });
  
    /* =========================
       해시 진입/변경 시 하이라이트
       ========================= */
    const flashFromHash = async () => {
      const id = location.hash.slice(1);
      if (!id) return;
      const el = document.getElementById(id);
      if (!el) return;
      const target = el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el;
      const container = getScrollContainer(target);
  
      // 뷰포트 안에 대략 보이는지 검사
      const viewTop = (container === document.scrollingElement || container === document.documentElement || container === document.body)
        ? 0
        : container.getBoundingClientRect().top;
      const r = target.getBoundingClientRect();
      const inView = (r.top - viewTop) >= 0 && (r.bottom - viewTop) <= (container.clientHeight || window.innerHeight);
  
      if (!inView) await scrollToTarget(container, target, SCROLL_MS, 0);
      highlight(target, HL_HOLD_MS);
    };
  
    window.addEventListener('hashchange', () => setTimeout(flashFromHash, 30));
    if (location.hash) setTimeout(flashFromHash, 60);
  });
  </script>
  
  

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.page-content ol > li').forEach(li => {
        // 이미 래퍼가 있으면 생략
        if (li.querySelector(':scope > .li-body')) return;
    
        const body = document.createElement('span'); // inline semantics 유지
        body.className = 'li-body';
    
        // 숫자 마커(::before) 외 모든 노드를 li-body로 이동
        while (li.firstChild) body.appendChild(li.firstChild);
        li.appendChild(body);
      });
    });
    </script>


<script>
  document.addEventListener("DOMContentLoaded", function() {
    const currentHost = window.location.hostname;
    const links = document.querySelectorAll('a[href^="http"]');
  
    links.forEach(link => {
      const url = new URL(link.href);
      if (url.hostname !== currentHost) {
        link.setAttribute("target", "_blank");
        link.setAttribute("rel", "noopener noreferrer");
      }
    });
  });
  </script>


  
  </body>
</html>
