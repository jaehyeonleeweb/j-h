<!DOCTYPE html>

  
  


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>잠재문학 제1선언문 · j-h</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- 0) 첫 페인트부터 폴백 감추기 (FOUT/FOIT 방지) -->
    <style>
      html:not(.wf-active):not(.wf-inactive) body { visibility: hidden; }
      html.wf-loading body { visibility: hidden; }
      html.wf-active body,
      html.wf-inactive body { visibility: visible; }
      html.wf-active body { animation: fontFadeIn .18s ease-out; }
      @keyframes fontFadeIn { from { opacity: 0 } to { opacity: 1 } }
    </style>

    <!-- 1) 폰트 커넥션 선연결 -->
    <link rel="preconnect" href="https://use.typekit.net" crossorigin>
    <link rel="preconnect" href="https://p.typekit.net" crossorigin>

    <!-- 2) Typekit 로더 -->
    <script>
      (function(d) {
        var config = { kitId: 'efe0obd', scriptTimeout: 3000, async: true },
            h = d.documentElement,
            t = setTimeout(function() {
              h.className = h.className.replace(/\bwf-loading\b/g,"") + " wf-inactive";
            }, config.scriptTimeout),
            tk = d.createElement("script"),
            f = false,
            s = d.getElementsByTagName("script")[0],
            a;
        h.className += " wf-loading";
        tk.src = "https://use.typekit.net/" + config.kitId + ".js";
        tk.async = true;
        tk.onload = tk.onreadystatechange = function() {
          a = this.readyState;
          if (f || (a && a !== "complete" && a !== "loaded")) return;
          f = true; clearTimeout(t);
          try { Typekit.load(config); } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>

    <!-- (선택) 개발 중 편의 -->
    <link rel="stylesheet" href="https://use.typekit.net/efe0obd.css">
    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <!-- 전체 2단 그리드 -->
    <div class="shell">
      <!-- 좌측: 세로 메뉴 -->
      <aside class="site-nav">
        <!-- ✅ 모바일 상단 바 (≤600px에서 보이도록 CSS 제어) -->
        <div class="nav-bar" role="navigation" aria-label="mobile top bar">
          <button class="nav-toggle" id="menu-toggle" aria-expanded="false" aria-controls="nav-menu">menu</button>
          
            <a href="&#x2F;glossary&#x2F;gl-001&#x2F;" class="lang-toggle">en</a>
          
        </div>

        <!-- ✅ 메인 메뉴: 데스크탑에서 항상 보이고, 모바일에선 토글 대상 -->
        <nav id="nav-menu" aria-label="primary">
          <a href="&#x2F;kr/">all archive</a><br>
          <a href="&#x2F;kr/works/">works</a><br>
          <a href="&#x2F;kr/about/">about</a><br>
          <a href="&#x2F;kr/contact/">contact</a><br>
        
          <!-- ⛔️ 비활성: 링크 대신 span, 클릭 불가, 회색(60%) -->
          <span class="nav-item nav-item--disabled" aria-disabled="true" title="Coming soon">shop</span>
        </nav>

        <!-- ✅ 데스크탑 전용 언어 토글: 메뉴 '아래 한 칸'에 표시 (모바일에선 CSS로 숨김) -->
        <div class="lang-toggle--desktop">
          
            <a href="&#x2F;glossary&#x2F;gl-001&#x2F;">en</a>
          
        </div>
      </aside>

      <!-- 우측: 콘텐츠 -->
      <main class="site-main">
        


<article class="page-two-col">
  
  <aside class="page-meta">
    <dl class="meta-list">
      
        <dt><h1>document no.:</h1></dt>
        <dd>4</dd>
      
  
      
        <dt><h1>category:</h1></dt>
        <dd>참조</dd>
      
  
      
  
      
  
      
  
      
        <dt><h1>author:</h1></dt>
        <dd>프랑수아 르 리오네</dd>
      

      

    </dl>
  </aside>

  <div class="page-body page-content">
    
    <h1 class="display-title">
      잠재문학 제1선언문
    </h1>
    <h2 id="daeumeun-ulripoyi-peurangsua-reu-rionega-sseun-jamjaemunhag-je1seoneonmun-eul-jamjaemunhagsilheomsil-namjongsin-oe-jageobsilyuryeong-2013-yi-beonyeoge-ddara-olmgin-geosida">*다음은 울리포의 프랑수아 르 리오네가 쓴  «잠재문학 — 제1선언문»<sup class="footnote-reference"><a href="#1">1</a></sup>을 «잠재문학실험실»(남종신 외, 작업실유령, 2013) 의 번역<sup class="footnote-reference"><a href="#2">2</a></sup>에 따라 옮긴 것이다.</h2>
<blockquote>
<p>사전<sup class="footnote-reference"><a href="#3">3</a></sup>을 펼쳐 단어를 찾아보자. ‘잠재문학’. 우리는 아무것도 찾지 못한다. 애석하게도 누락되어 있다. 다음의 글줄들은 나보다 더 적당히 써줄만한 배고픈 이들이 주요리가 나오기를 기다리면서 허기를 달래도록 마련해놓은 한낱 전채일 뿐이므로, 정의를 내리지는 않는다 해도, 어쨌든 몇몇 주안점을 제시해보려 한다.</p>
<p>언어의 발명을 수반했던 논쟁들을 기억하는가? 신비화, 유치한 상상력, 인종의 쇠락과 국가의 쇠퇴, 자연의 배반, 감성 훼손, 영감 모독, 이런 시기에 언어를 (언어 없이) 무엇으로 고발했던가.<br />
또한 문자와 문법의 창조, 이것의 이의 제기 없이 이루어졌을 거라 생각하는가? 신구논쟁은 실은 지속되고 있다. 이는 (1,750,000년 전) 진잔트로푸스와 더불어 시작되었고 그 뒤를 이을 돌연변이들이 확실히 계승하지 않는 한, 인류가 멸망해야만 종결될 것이다. 요컨대 논쟁은 오명을 얻었다. 고대인이라 불리는 이들은 대개 당대에는 현대인이었던 고루한 후손들이다. 이 현대인들이 우리 가운데 되살아난다면, 이들은 대부분 개혁자들의 편을 들며 자신들의 충성스런 모방자들을 저버릴 것이다.<br />
잠재문학은 단지 이러한 언쟁<sup class="footnote-reference"><a href="#4">4</a></sup> 가운데 밀려나온 새로운 활기를 드러낼 뿐이다.</p>
<p>모든 문학작품은 어떤 영감으로부터 이뤄지는데(적어도 그 작가가 넌지시 알리기로는 그렇다), 이 영감이란 러시아 인형처럼 하나를 다른 하나 안에 들이는 식의 일련의 제약과 절차들에 그럭저럭 적응해 나가고자 하는 데서 비롯된다. 어휘와 문법 제약들, 소설 작법 제약들(장 분류 등) 또는 고전 비극 작법 제약들(3막 구성), 일반적 작시법 제약들, 정형시 제약들(롱도나 소네트의 경우) 등등.<br />
우리는 이 주지의 조리법들에 매달리면서 새로운 공식들을 생각해내기를 완고히 거부해야만 할까? 보수주의 지지자들은 확신에 차 망설임 없이 대답한다. 그들의 확신은 이성적인 성찰에 기대기보다 습관의 힘에, 형식 속에서 그리고 그 실제적 법칙에 따라 획득되어온 일련의 걸작이(또한, 아아, 걸작에 미치지 못하는 작품들이) 안기는 감동에 기대는 쪽이다. 그래서 외침의 아름다움에, 한숨의 표현성에, 또한 훔쳐보기에(연인들에게는 이런 일들을 그만두라고 요구하지 않는 법) 민감한, 언어를 발명한 반대편들이 논거를 제시하게 되었던 것이다.<br />
인류는 새로운 사고방식이 낡은 시구들을 지어내도록 맡겨두고는 흡족해해야만 하는가? 우리는 그렇게 생각하지 않는다. 어떤 작가들은 그 방식에 재능이 있다고(심지어 천재라고) 소개되어 왔는데, 어떤 경우 우연일 뿐이고(새로운 단어를 단련해 쓰는 경우), 한 가지 방식만을 유달리 선호하는 이들도 있고(역운), 집요하게 한길을 걷는 이들도 있다(문자주의). 잠재문학작업실(OuLiPo)은 체계적이고 과학적으로, 필요하다면 정보처리 기계들의 도움을 받아가며 작업하고자 한다.</p>
<p>잠재문학작업실이 착수하려는 연구 가운데 두 가지 주요 경향을 구별해낼 수 있는데, 이 경향들은 각각 분석과 통합을 향한다. 분석적 경향은 과거의 작품들을 살핀다. 그 저자들이 짐작했던 바를 종종 넘어서는 가능성들을 찾아내기 위해서다. 일례로 표절 작품의 경우, 내가 보기에 마르코프과정의 이론에서 도출된 몇 가지를 고려해본다면 활력을 되찾을 수 있을지 모른다.<br />
통합적 경향은 훨씬 야심만만하다. 이는 울리포의 본질적 소명을 이룬다. 앞서 간 이들이 알지 못했던 새로운 길들을 열어나가는 것이 중요하다. «백조 편의 시(Cent mille milliards de poèmes)»또는 불대수적 하이카이가 그 예다.<br />
수학은—특히 현대 수학의 추상적 구조는—우리에게 대수적으로(새로운 결합 법칙들을 만들겠다는 의지) 그리고 위상기하학적으로(원문에의 접근, 개방성 또는 폐쇄성에 대한 고려) 수천 가지 탐구 방향을 제안한다. 또한 우리는 부조 인쇄된 시를, 투영에 의해 변형될 수 있는 텍스트들을, 그 밖의 것들을 떠올려본다. 또 다른, 주로 특정 어휘 영역을 공략할 기습들도 상상해볼 수 있겠다(까마귀, 여우, 돌고래, 또는 전자 컴퓨터 알골 언어 등). 이제부터 언뜻 보이는, 때로는 초안이 될 이러한 가능성들을 열거하려면 참으로 긴 논문이어야만할 것이다.<br />
씨앗을 살펴보는 것만으로는 햇과일의 맛이 어떨지 미리 식별해내기가 쉽지 않다. 알파벳 제약의 경우를 살펴보자. 문학에서, 이러한 제약은 엄청난 작품들(그렇기는 하지만, 비용 그리고 물론 그 전에 «시편»의 작자와 예레미야가 읊는 «애가»의 저자가 있었다⋯⋯)을 생산해냈다고 단언할 수밖에 없는 이합체 시로 이어질 수 있다. 미술에서는 아주 뛰어난 오귀스트 에르뱅을 낳았다. 음악에서는 바흐라는 이름에 드리운, 존경해 마땅한 푸가가 있다. 알파벳을 만든 이들이 어떻게 이 모든 일을 짐작할 수 있었겠는가?<br />
요컨데 분석울리피즘(Anoulipisme)은 발견에, 통합울리피즘(Synthouloipisme)은 발명에 헌신하게 된다. 하나에서 다른 하나까지 여러 미묘한 통로가 존재한다.</p>
<p>하나의 단어란 결국, 농담적 성향을 드러내보이는 작품이라면 어떤 것이든 검토해보지도 않고 단호히 단죄해버리는, 유난히 심각한 사람들을 위한 것.<br />
그러한 작업들이 시인의 행위라면, 오락, 장난, 속임수들 역시 시의 영역에 속한다. 그러므로 잠재문학은 세상에서 가장 진지한 것으로 남게 된다. ‘증명 완료.’</p>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>François Le Lionnais, «Lipo: First Manifesto», 1960, Oulipo. (Available at: https://www.oulipo.net)</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>남종신 외, «잠재문학실험실», 작업실유령, 2013, 123–129쪽.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>원주: 어떤 사전이든</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>원주: 어떻게 언쟁 중 활기가 싹틀 수 있는가? 우리는 시가 아니라 식물생리학의 영역에 속하는 이 질문에 무관심해지고 있다.</p>
</div>


    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const content = document.querySelector('.page-content');
        if (!content) return;
      
        /* ---------------------------------------------
         * 1) 흩어진 각주 아이템을 .footnotes 컨테이너로 래핑
         *    - 대상: .footnote-definition, li[id^="fn"]
         *    - 이미 .footnotes가 있으면 건너뜀
         * --------------------------------------------- */
        let wrap = content.querySelector('.footnotes');
        if (!wrap) {
          const items = Array.from(
            content.querySelectorAll('.footnote-definition, li[id^="fn"]')
          );
          if (items.length) {
            const parent = items[0].parentElement;
            const group = items.filter(el => el.parentElement === parent);
            if (group.length) {
              wrap = document.createElement('div');
              wrap.className = 'footnotes';
              wrap.setAttribute('role', 'doc-endnotes');
              wrap.setAttribute('aria-label', 'Footnotes');
              parent.insertBefore(wrap, group[0]);
              group.forEach(el => wrap.appendChild(el));
            }
          }
        }
      
        /* ---------------------------------------------
         * 2) 각주 본문(p) 내 URL을 <a>로 자동 변환
         *    - 호환: http/https/www
         *    - 말미의 쉼표/마침표/괄호 등은 제외
         * --------------------------------------------- */
        if (wrap) {
          const URL_RE = /((?:https?:\/\/|www\.)[^\s<>()]+?)(?=[\s<>()]|$)/g;
      
          wrap.querySelectorAll('.footnote-definition > p, li[id^="fn"] > p')
            .forEach(p => {
              if (p.dataset.autolinked === '1') return;
              p.innerHTML = p.innerHTML.replace(URL_RE, (m, url) => {
                const href = url.startsWith('http') ? url : `https://${url}`;
                return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
              });
              p.dataset.autolinked = '1';
            });
      
          // 안전: 링크 rel 보정
          wrap.querySelectorAll('a').forEach(a => {
            const rel = (a.getAttribute('rel') || '').split(/\s+/);
            ['noopener','noreferrer'].forEach(tok => { if (!rel.includes(tok)) rel.push(tok); });
            a.setAttribute('rel', rel.join(' ').trim());
          });
        }
      });
      </script>
      
  </div>

</article>


      </main>
    </div>

    <!-- Footer -->
    <footer class="site-footer" role="contentinfo" aria-label="site footer">
      <p class="site-footer__text">
        j-h, jaydashaitch, online archive of jae hyeon lee. ©2025 jaehyeon lee
      </p>
      <p class="site-footer__text--mobile">
        j-h, ©2025 jaehyeon lee
      </p>
    </footer>

    <!-- Hangul span 래핑 스크립트 -->
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const HANGUL_RE = /([\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3]+)/g;
        const SKIP_SELECTOR = 'pre, code, kbd, samp, script, style';
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !HANGUL_RE.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
              let p = node.parentNode;
              while (p && p !== document.body) {
                if (p.matches && p.matches(SKIP_SELECTOR)) return NodeFilter.FILTER_REJECT;
                p = p.parentNode;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        const texts = [];
        let n;
        while (n = walker.nextNode()) texts.push(n);
        for (const text of texts) {
          const span = document.createElement('span');
          span.innerHTML = text.nodeValue.replace(HANGUL_RE, '<span class="han">$1</span>');
          text.parentNode.replaceChild(span, text);
        }
      });
    </script>

    <!-- ✅ Mobile Menu Script -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const btn = document.getElementById("menu-toggle");
        const menu = document.getElementById("nav-menu");
        if (!btn || !menu) return;

        function closeMenu() {
          menu.classList.remove("open");
          btn.setAttribute("aria-expanded", "false");
        }

        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.toggle("open");
          btn.setAttribute("aria-expanded", String(isOpen));
        });

        document.addEventListener("click", (e) => {
          if (!menu.contains(e.target) && !btn.contains(e.target)) closeMenu();
        });

        window.addEventListener("resize", () => {
          if (window.innerWidth > 600) closeMenu();
        });
      });
    </script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (window.__FN_WIRED__) return;
    window.__FN_WIRED__ = true;
  
    /* =========================
       설정값
       ========================= */
    const SCROLL_MS   = 300;   // 부드럽지만 빠르게
    const HL_IN_MS    = 200;   // 페이드 인
    const HL_OUT_MS   = 700;   // 페이드 아웃(느리게)
    const HL_HOLD_MS  = 800;   // 유지 시간(짧게 유지 후 서서히 사라짐)
  
/* =========================
   스크롤 유틸 (컨테이너 대응, quintic S-curve + out-bias)
   ========================= */
   const isScrollable = (el) => {
  if (!el) return false;
  const s = getComputedStyle(el);
  const oy = s.overflowY;
  return (oy === "auto" || oy === "scroll") && el.scrollHeight > el.clientHeight;
};

const getScrollContainer = (el) => {
  let node = el.parentElement;
  while (node && node !== document.body && node !== document.documentElement) {
    if (isScrollable(node)) return node;
    node = node.parentElement;
  }
  return document.scrollingElement || document.documentElement || document.body;
};

/* =========================
   스크롤 애니메이션 (quintic S-curve + out-bias)
   - 부드러운 시작, 끈적한 감속
   ========================= */
const easeInOutSticky = (t) => {
  // Quintic smoothstep (C2 연속, S-curve)
  const t2 = t * t, t3 = t2 * t, t4 = t2 * t2, t5 = t4 * t;
  const base = 6 * t5 - 15 * t4 + 10 * t3; // 기본 S-curve
  const OUT_BIAS = 1.12; // 1.0~1.2 권장 (↑ = 더 끈적한 감속)
  return 1 - Math.pow(1 - base, OUT_BIAS);
};

const scrollToTarget = (container, target, ms = SCROLL_MS, offsetY = 0) =>
  new Promise((resolve) => {
    const containerIsDoc =
      container === document.scrollingElement ||
      container === document.documentElement ||
      container === document.body;

    const containerRect = containerIsDoc
      ? { top: 0 }
      : container.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    const start = containerIsDoc
      ? window.pageYOffset || document.documentElement.scrollTop
      : container.scrollTop;

    const targetY = start + (targetRect.top - containerRect.top) + offsetY;

    if (ms <= 0) {
      if (containerIsDoc) window.scrollTo(0, targetY);
      else container.scrollTop = targetY;
      resolve();
      return;
    }

    const startTime = performance.now();
    const step = (now) => {
      const t = Math.min(1, (now - startTime) / ms);
      const eased = easeInOutSticky(t);
      const y = start + (targetY - start) * eased;

      if (containerIsDoc) window.scrollTo(0, y);
      else container.scrollTop = y;

      if (t < 1) {
        requestAnimationFrame(step);
      } else {
        if (containerIsDoc) window.scrollTo(0, targetY);
        else container.scrollTop = targetY;
        resolve();
      }
    };

    requestAnimationFrame(step);
  });

  
    /* =========================
       하이라이트 (빠른 IN → 유지 → 느린 OUT)
       ========================= */
    const highlight = (host, hold = HL_HOLD_MS) => {
      if (!host) return;
      host.classList.add('fn-hl');  // 초기 상태(투명) + 트랜지션 규칙
      // 다음 프레임에 ON
      requestAnimationFrame(() => {
        host.style.setProperty('--fn-hl-in',  `${HL_IN_MS}ms`);
        host.style.setProperty('--fn-hl-out', `${HL_OUT_MS}ms`);
        host.classList.add('is-on');           // 빠르게 켜짐
        setTimeout(() => {
          host.classList.add('is-fading');     // 느리게 꺼짐
          host.classList.remove('is-on');
          setTimeout(() => host.classList.remove('fn-hl', 'is-fading'), HL_OUT_MS + 30);
        }, hold);
      });
    };
  
    /* =========================
       매핑: 본문 참조 ↔ 각주 블록
       ========================= */
    const allIds = new Set([...document.querySelectorAll('[id]')].map(el => el.id));
    const bodyLinks = [...document.querySelectorAll('.page-content a[href^="#"]')]
      .filter(a => !a.closest('.footnote-definition') && !a.closest('.footnotes'));
  
    const footnoteIds = new Set(
      bodyLinks
        .map(a => (a.getAttribute('href') || '').slice(1))
        .filter(id => id && allIds.has(id))
    );
  
    const getFootnoteBlock = (id) => {
      const el = document.getElementById(id);
      return el
        ? (el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el)
        : null;
    };
  
    const backMap = new Map();
    bodyLinks
      .filter(a => footnoteIds.has((a.getAttribute('href') || '').slice(1)))
      .forEach(a => {
        const id = a.getAttribute('href').slice(1);
        const sup = a.closest('sup[id^="fnref"]') || a.closest('sup');
        const target = sup || a;
        if (!target.id) {
          let base = `fnref-auto-${id}`, i = 1, uid = base;
          while (document.getElementById(uid)) uid = `${base}-${i++}`;
          target.id = uid;
        }
        backMap.set(id, target.id);
      });
  
    /* =========================
       이벤트: 본문 → 각주
       ========================= */
    document.addEventListener('click', async (e) => {
      const ref = e.target.closest('.page-content a[href^="#"]');
      if (!ref || ref.closest('.footnote-definition') || ref.closest('.footnotes')) return;
  
      const hash = ref.getAttribute('href') || '';
      if (!hash.startsWith('#')) return;
  
      const id = hash.slice(1);
      if (!footnoteIds.has(id)) return;
  
      e.preventDefault();
      const fnBlock = getFootnoteBlock(id);
      if (!fnBlock) return;
  
      const container = getScrollContainer(fnBlock);
      await scrollToTarget(container, fnBlock, SCROLL_MS, 0);
      history.pushState(null, '', `#${id}`);
      highlight(fnBlock, HL_HOLD_MS);
    });
  
    /* =========================
       이벤트: 각주 → 본문
       ========================= */
    document.addEventListener('click', async (e) => {
      const a = e.target.closest('a');
      if (a) {
        const href = a.getAttribute('href') || '';
        if (href && !href.startsWith('#')) return; // 외부 링크는 방해하지 않음
      }
  
      let node = e.target.closest('[id]');
      while (node) {
        const id = node.id;
        if (footnoteIds.has(id)) {
          const backId = backMap.get(id);
          if (backId) {
            e.preventDefault();
            const backEl = document.getElementById(backId) || document.querySelector(`a[href="#${id}"]`);
            if (!backEl) return;
            const container = getScrollContainer(backEl);
            await scrollToTarget(container, backEl, SCROLL_MS, 0);
            history.pushState(null, '', `#${backId}`);
            highlight(backEl, HL_HOLD_MS);
          }
          return;
        }
        node = node.parentElement;
      }
    });
  
    /* =========================
       해시 진입/변경 시 하이라이트
       ========================= */
    const flashFromHash = async () => {
      const id = location.hash.slice(1);
      if (!id) return;
      const el = document.getElementById(id);
      if (!el) return;
      const target = el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el;
      const container = getScrollContainer(target);
  
      // 뷰포트 안에 대략 보이는지 검사
      const viewTop = (container === document.scrollingElement || container === document.documentElement || container === document.body)
        ? 0
        : container.getBoundingClientRect().top;
      const r = target.getBoundingClientRect();
      const inView = (r.top - viewTop) >= 0 && (r.bottom - viewTop) <= (container.clientHeight || window.innerHeight);
  
      if (!inView) await scrollToTarget(container, target, SCROLL_MS, 0);
      highlight(target, HL_HOLD_MS);
    };
  
    window.addEventListener('hashchange', () => setTimeout(flashFromHash, 30));
    if (location.hash) setTimeout(flashFromHash, 60);
  });
  </script>
  
  

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.page-content ol > li').forEach(li => {
        // 이미 래퍼가 있으면 생략
        if (li.querySelector(':scope > .li-body')) return;
    
        const body = document.createElement('span'); // inline semantics 유지
        body.className = 'li-body';
    
        // 숫자 마커(::before) 외 모든 노드를 li-body로 이동
        while (li.firstChild) body.appendChild(li.firstChild);
        li.appendChild(body);
      });
    });
    </script>


<script>
  document.addEventListener("DOMContentLoaded", function() {
    const currentHost = window.location.hostname;
    const links = document.querySelectorAll('a[href^="http"]');
  
    links.forEach(link => {
      const url = new URL(link.href);
      if (url.hostname !== currentHost) {
        link.setAttribute("target", "_blank");
        link.setAttribute("rel", "noopener noreferrer");
      }
    });
  });
  </script>


  
  </body>
</html>
