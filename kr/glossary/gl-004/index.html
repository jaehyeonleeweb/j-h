<!DOCTYPE html>


  


<script>
  console.log("current_path:", "/kr/glossary/gl-004/");
</script>

<script>
  console.log("lang:", "kr");
  console.log("section.lang:", "(no section)");
  console.log("page.lang:", "kr");
</script>


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>도둑질의 정신, 제이대시에이치</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">

    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <header class="header" role="banner">
      <button
        class="menu-toggle"
        id="menu-toggle"
        aria-expanded="false"
        aria-controls="global-menu"
      >
       
          메뉴
       
      </button>

      <a href="&#x2F;kr/" class="site-title" id="site-title"></a>

      <span class="lang-toggle" data-lang="kr">
        
        <span class="ko">한</span>
        <span class="sep"> / </span>
        
          <a href="&#x2F;glossary&#x2F;gl-004&#x2F;" class="en">EN</a>
        
        
      </span>
      
    </header>

    <nav
      id="global-menu"
      class="global-menu"
      aria-label="primary"
      hidden
    >
      
        <a href="&#x2F;kr/allarchive/">모든 아카이브</a>
        
        <a href="&#x2F;kr/about/">이 웹에 대하여</a>
        <a href="&#x2F;kr/contact/">연락처</a>
        <span class="menu-item--disabled" aria-disabled="true">구매</span>
      
    </nav>

    <main id="content">
      

<article class="page-two-col" role="article">

  <aside class="page-meta" role="complementary">

    <div class="meta-block meta-title">
      <strong>도둑질의 정신</strong>
    </div>

    <div class="meta-block meta-data">

      
        <div class="meta-line">
          
            문서 번호 → [18]
          
        </div>
      
    
      
        <div class="meta-line">
          
            카테고리 → [참조]
          
        </div>
      
    
      
      <div class="meta-line">
        
          저자 →
        
    
        
        
          [민구홍]
        
      </div>
    
    
    
    
    
    
    
    
    
    

      
  
  
    
    </div>
    

    
    <div class="meta-block meta-desc">
      
        <div class="meta-line">
          ※ 이 문서는 『“도둑질은 좋다.”』(민구홍, QR, 2025)의 일부인 「도둑질의 정신」을 도둑질한 것이다.
        </div>
      
        <div class="meta-line">
          ※ <a rel="external" href="https://minguhongmfg.com/products/stealing-is-good">minguhongmfg.com/products/stealing-is-good</a>
        </div>
      
    </div>
    
    

    
    

  </aside>

  <div class="page-body page-content">

    <p>도둑질은 그저 손재주나 기술의 문제가 아니다. 그보다는 세상을 바라보는 방식, 창작을 대하는 태도에 가깝다. 창작에서 이 괴상한 행위는 남의 것을 슬쩍하는 동시에 기어이 자기를 드러내는 자기 과시이기도 하다. 더 우울하게 재미있는 것은 무언가를 가져올수록 ‘진정한 나’에 가까워진다는 궤변이다. 이제 도둑질의 정신 열세 가지 강령을 펼쳐본다. 어딘가 썩은 유머 같아도 동결 건조 젤리만큼은 곱씹어볼 가치는 있다.
<br><br></p>
<p><strong>도둑질은 손기술이 아닌 정신이다</strong><br>
그저 남의 것을 베끼는 능력은 제록스 복사 기술에 불과하다. 진짜 도둑질은 세상을 ‘훔칠 만한 것들의 거대한 저장고’로 인식하는 관점에서 비롯한다. 길가의 돌멩이 하나, 흘러가는 대화 한 조각, 오래된 영화의 한 장면까지 모든 것을 잠재적 전리품으로 보는 시선, ‘저걸 내 작업에 가져오면 어떨까?’라는 문장을 끊임없이 던지는 마음가짐이야말로 도둑질의 출발점이다. 기술은 그 다음 문제다. 일단 훔치겠다고 마음먹는 정신이 먼저다.
<br><br></p>
<p><strong>모든 창작자는 본질적으로 도둑이다.</strong><br>
“좋은 예술가는 베끼고, 위대한 예술가는 훔친다.”라는 피카소의 말은 그저 대가인 척 멋이나 부리려는 소리가 아니다. 셰익스피어는 옛 이야기를 훔쳐 자기 것으로 만들었고, 바흐는 선배들의 선율을 분해하고 재조립했다. 고상한 현대 예술가도 알게 모르게 서로의 아이디어를 슬쩍하고 영감을 빌린다. 하늘 아래 새로운 것은 없다는 진실을 인정하는 순간, 우리는 모두 도둑이라는 현실과 마주한다. 차이는 얼마나 뻔뻔하게, 또는 얼마나 세련되게 훔치는지에 있을 뿐이다.
<br><br></p>
<p><strong>좋은 도둑은 안목 있게 훔치고 영리하게 편집한다.</strong><br>
아무거나 닥치는 대로 훔쳐 레인보 셔벗을 엉망진창으로 만드는 것은 하수 가운데 하수다. 진짜 실력은 ‘무엇을 훔칠 것인가’를 알아보는 날카로운 안목에서 드러난다. 남들이 지나치는 것에서 가치를 발견하고, 자기 작업의 맥락에 정확히 들어맞는 조각을 찾아내는 능력. 그리고 훔쳐온 것을 그대로 쓰기보다는 자기 스타일로 변형하고, 다른 요소와 충돌시키거나 조화롭게 배치하는 편집 감각. 이것이 결과를 가른다. 좋은 도둑질은 그저 기계적인 가져오기가 아닌 빼어난 큐레이션이자 재창조 작업이다.
<br><br></p>
<p><strong>훔치고 싶은 욕망은 감탄과 사랑의 다른 이름이다.</strong><br>
무언가를 훔치고 싶다는 강렬한 욕망은 역설적으로 그것에 대한 깊은 감탄과 사랑에서 비롯한다. 그 문장의 완벽한 리듬, 그 이미지의 충격적인 아름다움, 그 이야기 구조의 정교함에 매료되지 않고서는 훔치고 싶은 마음조차 들지 않는다. 물론, 이는 내 것이 아닌 것을 탐하는 심보를 미화하는 것일 수도 있지만, 그 이면에 대상에 대한 지독한 관심과 분석, 즉 일종의 ‘덕질’, 즉 도저한 사랑이 깔려 있다는 점은 부정하기 어렵다.
<br><br></p>
<p><strong>따라서 창작적 도둑질은 헌사일 수 있다.</strong><br>
앞선 이야기를 이어받아 ‘감탄과 사랑에 기반한 도둑질’은 원작자를 향한 존경과 감사의 표현, 즉 일종의 ‘헌사’가 될 수 있다. 좋아하는 작가의 문체를 무심코 따라 쓰거나 존경하는 감독의 장면을 오마주하거나 흠모하는 그래픽 디자이너의 시각 언어를 따라 해보는 행위들. 물론 이는 진실로 순수한 존경일 수도, 자기 독창성의 부족을 가리는 편리한 핑계일 수도 있다. 중요한 것은 결과물이 그럴듯하게 보인다면, 사람들은 기꺼이 ‘헌사’라는 아름다운 이름표를 붙여준다는 사실이다. 얄궂게도 해석은 언제나 승리자의 몫인 까닭이다.
<br><br></p>
<p><strong>세상에 원래 ‘내 것’은 없다. 모든 것은 빌려온 것이다.</strong><br>
당신이 쓰는 단어, 문장 구조, 플롯 장치, 심지어 독창적이라 믿는 당신의 아이디어까지. 파고 들어가 보면 뿌리는 이미 존재한 무언가에 닿아 있다. 언어는 사회적 약속이고, 이야기는 인류 공통의 원형을 변주하며, 감정 표현 방식조차 학습된 것이다. 이 냉정한 현실을 받아들이면 ‘무에서 유를 창조해야 한다’는 강박에서 조금은 자유로워질 수 있다. 나아가 모든 것이 빌려온 것이라면, 중요한 것은 ‘무엇을 빌려와 어떻게 새롭게 조합하는가’의 문제가 된다.
<br><br></p>
<p><strong>남의 것을 통해 나를 말하는 역설, 그게 창작이다.</strong><br>
완전히 새로운 언어를 발명할 수 없다면, 우리는 빌려온 언어로 자신을 표현할 수밖에 없다. 남이 쓴 단어, 남이 만든 구조를 가져와 내 감정을 담고 내 시선을 투영할 때, 비로소 그것은 나의 것이 된다. 남의 옷을 빌려 입었는데 이상하게 내게 더 잘 어울리는 것처럼 말이다. 이 과정은 기계적인 모방을 넘어 외부 세계와의 상호작용을 통해 자아를 형성하고 발현하는 창작의 본질적 메커니즘이다. 남의 목소리를 흉내 내는 과정 속에서 진짜 내 목소리를 찾는 역설.
<br><br></p>
<p><strong>도둑질은 불안을 인정하고 망각에 저항하는 행위다.</strong><br>
창작자는 늘 불안하다. 내가 하는 이야기가 이미 있을까? 이미 누군가 한 이야기는 아닐까? 게다가 나만의 것이 있긴 한가? 도둑은 이 불안을 회피하지 않고 정면으로 마주한다. “그래, 이건 나 혼자 만든 건 아니지만, 여기서 이 조합은, 이 관점은 분명히 내 거야.” 하고 선언하는 행위인 동시에 잊힐 위기에 처한 과거의 좋은 것을 현재로 다시 불러내 재조명함으로써 망각에 저항한다. 도둑질은 과거와의 대화인 동시에 사라져가는 것에 대한 애도의 방식이기도 하다.
<br><br></p>
<p><strong>훔쳐온 것에 새 생명을 불어넣는 것.</strong><br>
박물관에 박제된 유물처럼 죽어 있던 문장, 낡은 필름처럼 빛바랜 이미지, 화석처럼 굳어 있던 아이디어를 가져와 당신의 작업 속에서 다시 숨 쉬게 만드는 것. 이것이 도둑질이 추구하는 ‘창조적 부활’이다. 물론, 잘못하면 그냥 죽은 것을 파헤쳐 전시하는 네크로맨시(Necromancy)처럼 보일 위험도 있다. 중요한 것은 단순한 이식보다 당신의 맥락과 감성으로 새로운 피를 수혈해 전혀 다른 생명체로 만들어내는 능력이다.
<br><br></p>
<p><strong>좋은 도둑은 흔적을 감추지 않고, 오히려 드러낸다.</strong><br>
어떤 도둑은 어떻게든 훔친 티를 감추려 발버둥 치지만, 어떤 도둑은 오히려 흔적을 슬쩍 드러내며 자신의 감식안과 변형 능력을 과시한다. 인용 부호를 달거나, 인터뷰에서 영향받은 사실을 언급하거나, 작품 속에 교묘하게 오마주를 숨겨두는 방식으로 말이다. 이는 정직함을 넘어 자신감의 표현이다. “그래. 나는 이 정도까지 알고 있고, 이걸 이렇게 바꿀 능력도 있지.” 물론, 이는 이따금 비난을 피하기 위한 계산된 솔직함일 수도 있음을 부정하기 어렵다.
<br><br></p>
<p><strong>출처를 밝히는 것은 책임감이며, 사기와 창작을 가른다.</strong><br>
자신이 어디서 영감을 얻었는지, 어떤 작품의 영향을 받았는지 투명하게 밝히는 태도는 그저 법적 문제를 피하기 위한 수단이 아니다. 이는 창작 생태계의 일원으로서 선배와 동료들에게 보내는 존중의 표시인 동시에 자신의 작업을 더 넓은 문화적 맥락 위에 올려놓는 행위다. 반대로 출처를 의도적으로 숨기려 애쓰고, 특히 소셜 미디어에서 모든 영광을 독차지하려는 행위는 명백한 사기이자 기만이다. 물론, 대관절 출처를 어디까지 밝혀야 하는지에 대한 명확한 답이 없다는 게 문제지만. 이는 어느 정도는 당신이 이제껏 체득한 ‘분위기를 읽는 감각’에 달렸다.
<br><br></p>
<p><strong>물론, 훔치다 망치는 길도 있다.</strong><br>
모든 도둑질이 성공적인 창작으로 이어지는 것은 아니다. 원작에 관한 깊은 이해 없이 껍데기만 가져오거나, 자기 작업의 맥락과 어울리지 않는 요소를 끼워 넣거나, 가져온 것을 변형할 능력 없이 안일하게 복제하는 경우, 결과는 참담하기 그지없다. 이런 도둑질은 원작의 아우라에 기대는 지루한 아류작, 아무런 감흥도 주지 못하는 어설픈 짜깁기에 불과하다. 도둑질에도 격이 있고, 안목과 고민 없는 도둑질은 무덤으로 직행하는 길이다.
<br><br></p>
<p><strong>하이퍼링크의 세계관, 그리고 마지막 질문.</strong><br>
결국 도둑질은 ‘나는 고립된 존재가 아니며, 모든 것은 서로 연결돼 있다’는 하이퍼링크의 세계관에 닿아 있다. 나는 과거의 유산 위에 서 있고, 동시대의 흐름 속에서 호흡하며, 미래 세대에 무언가를 남긴다. 남의 어깨를 딛고 서서 빌려온 렌즈로 세상을 바라보는 것. 이것이 창작자가 세계와 관계 맺는 방식이다. 그러니 진짜 던져야 할 질문은 ‘훔쳐도 되는가?’라는 순진무구한 질문이 아닌 바로 이것이다. ‘과연, 훔치지 않고 우리가 무엇을 창조할 수 있기는 한가?’</p>


  </div>

</article>

<div id="image-viewer" aria-hidden="true">
  <button class="viewer-close" aria-label="Close">×</button>
  <button class="viewer-prev" aria-label="Previous">←</button>
  <img class="viewer-image" alt="" />
  <button class="viewer-next" aria-label="Next">→</button>
</div>


<script>
  (function () {
  
    function isVisible(el) {
      return !!(el && el.offsetParent !== null);
    }
  
    function isInViewport(el) {
      if (!el) return false;
      const r = el.getBoundingClientRect();
      return r.bottom > 0 && r.top < window.innerHeight;
    }
  
    function scrollToRef(el, block) {
      if (!el) return;
      el.scrollIntoView({
        behavior: "smooth",
        block: block
      });
    }
  
    function scrollDocumentToRevealMeta() {
      window.scrollTo({
        top: document.documentElement.scrollHeight,
        behavior: "smooth"
      });
    }
  
    function setActiveFootnote(id) {
      history.pushState(null, "", "#" + id);
  
      document.querySelectorAll(".meta-note").forEach(el => {
        el.classList.toggle("is-active", el.dataset.fnid === id);
      });
  
      document.querySelectorAll(".footnotes-list li[id]").forEach(el => {
        el.classList.toggle("is-active", el.id === id);
      });
    }
  
    const mqDesktop = window.matchMedia("(min-width: 600px)");
  
    document.addEventListener("click", function (e) {
  
      const meta = e.target.closest(".meta-note[data-fnid]");
      if (meta) {
        if (e.target.closest("a")) return;
  
        const id = meta.dataset.fnid;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const def = e.target.closest(".footnotes-list li[id]");
      if (def) {
        if (e.target.closest("a")) return;
  
        const id = def.id;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const refLink = e.target.closest(".footnote-reference a[href^='#']");
      if (!refLink) return;
  
      e.preventDefault();
  
      const id = refLink.getAttribute("href").slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
  
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
    document.addEventListener("DOMContentLoaded", function () {
      if (!location.hash.startsWith("#")) return;
  
      const id = location.hash.slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
  })();
  </script>  
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const PUNCTS = `"'\u2018\u201C([{‹«〈《「『`;
    
        const targets = document.querySelectorAll(
  '.page-meta .meta-title, \
   .page-meta .meta-line, \
   .page-body .page-content p, \
   .page-body .page-content li'
);

    
      targets.forEach(el => {
        const text = (el.textContent || '').trimStart();
        if (!text) return;
    
        const firstChar = text[0];
        if (!PUNCTS.includes(firstChar)) return;
    
        el.classList.add('hang-punct');
      });
    });
    </script>
    
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const superscriptMap = {
          "0": "⁰",
          "1": "¹",
          "2": "²",
          "3": "³",
          "4": "⁴",
          "5": "⁵",
          "6": "⁶",
          "7": "⁷",
          "8": "⁸",
          "9": "⁹"
        };
      
        document
          .querySelectorAll("sup.footnote-reference a")
          .forEach(el => {
            const text = el.textContent.trim();
      
            if (!/^\d+$/.test(text)) return;
      
            const superscript = [...text]
              .map(d => superscriptMap[d] || d)
              .join("");
      
            el.textContent = superscript;
            el.setAttribute("aria-label", `Footnote ${text}`);
          });
      });
      </script>
      
      <script>
        (function () {
          const root = document.querySelector(".page-body.page-content");
          if (!root) return;

          root.querySelectorAll("blockquote ol > li").forEach(li => {
            if (li.querySelector(":scope > .li-body")) return;

            const body = document.createElement("span");
            body.className = "li-body";

            const nodes = Array.from(li.childNodes);

            nodes.forEach(node => {
              if (
                node.nodeType === Node.ELEMENT_NODE ||
                (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "")
              ) {
                body.appendChild(node);
              }
            });

            li.appendChild(body);
          });
        })();
        </script>


        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const root = document.querySelector(".page-body.page-content");
            if (!root) return;
          
            root.querySelectorAll("p > strong").forEach(strong => {
              const parent = strong.parentElement;
              if (parent && parent.classList.contains("centered-strong")) return;
          
              const wrapper = document.createElement("span");
              wrapper.className = "centered-strong";
          
              parent.replaceChild(wrapper, strong);
              wrapper.appendChild(strong);
            });
          });
          </script>
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const isMobile = window.matchMedia("(max-width: 600px)").matches;
    
      const images = Array.from(
        document.querySelectorAll(".page-body.page-content figure img")
      );
      if (!images.length) return;
    
      const viewer = document.getElementById("image-viewer");
      const viewerImg = viewer.querySelector(".viewer-image");
      const btnClose = viewer.querySelector(".viewer-close");
      const btnPrev = viewer.querySelector(".viewer-prev");
      const btnNext = viewer.querySelector(".viewer-next");
    
      let currentIndex = 0;
      let scrollY = 0;
    
      function lockScroll() {
        scrollY = window.scrollY;
        document.body.style.position = "fixed";
        document.body.style.top = `-${scrollY}px`;
        document.body.style.left = "0";
        document.body.style.right = "0";
        document.body.style.width = "100%";
      }
    
      function unlockScroll() {
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.left = "";
        document.body.style.right = "";
        document.body.style.width = "";
        window.scrollTo(0, scrollY);
      }
    
      function openViewer(index) {
        currentIndex = index;
        viewerImg.src = images[currentIndex].src;
        viewer.classList.add("is-open");
        viewer.setAttribute("aria-hidden", "false");
    
        if (isMobile) lockScroll();
      }
    
      function closeViewer() {
        viewer.classList.remove("is-open");
        viewer.setAttribute("aria-hidden", "true");
    
        if (isMobile) unlockScroll();
      }
    
      function prev() {
        if (currentIndex > 0) openViewer(currentIndex - 1);
      }
    
      function next() {
        if (currentIndex < images.length - 1) openViewer(currentIndex + 1);
      }
    
      images.forEach((img, i) => {
        img.style.cursor = "zoom-in";
        img.addEventListener("click", () => openViewer(i));
      });
    

      if (!isMobile) {
        btnClose.addEventListener("click", closeViewer);
        btnPrev.addEventListener("click", prev);
        btnNext.addEventListener("click", next);
    
        viewerImg.addEventListener("click", closeViewer);
        viewer.addEventListener("click", e => {
          if (e.target === viewer) closeViewer();
        });
      }
    
      if (isMobile) {
        viewer.addEventListener("click", closeViewer);
    
        let startX = 0;
        let startY = 0;
    
        viewer.addEventListener(
          "touchstart",
          e => {
            const t = e.touches[0];
            startX = t.clientX;
            startY = t.clientY;
          },
          { passive: true }
        );
    
        viewer.addEventListener("touchend", e => {
          const t = e.changedTouches[0];
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
    
          if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
            dx > 0 ? prev() : next();
          }
        });
      }
    
      document.addEventListener("keydown", e => {
        if (!viewer.classList.contains("is-open")) return;
    
        if (e.key === "Escape") closeViewer();
        if (e.key === "ArrowLeft") prev();
        if (e.key === "ArrowRight") next();
      });
    });
    </script>
    

    <script>
      (function () {
        if (!window.matchMedia("(min-width: 601px)").matches) return;
    
        const preview = document.createElement("div");
        preview.id = "link-preview";
        document.body.appendChild(preview);
    
        let aborter = null;
    
        function isHomeLink(a) {
          if (!a || !a.href) return false;
          try {
            const url = new URL(a.href);
            if (url.origin !== location.origin) return false;
            return url.pathname === "/" || url.pathname === "/kr/";
          } catch {
            return false;
          }
        }
    
        function isInternalLink(a) {
          if (!a || !a.href) return false;
          try {
            return new URL(a.href).origin === location.origin;
          } catch {
            return false;
          }
        }
    
        function extractPreviewText(html) {
          const doc = new DOMParser().parseFromString(html, "text/html");
          const body = doc.querySelector(".page-body");
          if (!body) return "";
    
          body.querySelectorAll(
            "figure, img, pre, code, table, script, style, .footnotes, .footnotes-list, aside"
          ).forEach(el => el.remove());
    
          body.querySelectorAll("sup").forEach(el => el.remove());
    
          const candidates = Array.from(body.querySelectorAll("p, li"))
            .map(el => el.textContent.replace(/\s+/g, " ").trim())
            .filter(text => text.length > 0);
    
          return candidates[0] || "";
        }
    
        function positionPreview(e) {
          const offset = 14;
          const maxX = window.innerWidth - preview.offsetWidth - 8;
          const maxY = window.innerHeight - preview.offsetHeight - 8;
    
          preview.style.left = Math.min(e.clientX + offset, maxX) + "px";
          preview.style.top = Math.min(e.clientY + offset, maxY) + "px";
        }
    
        document.addEventListener("mouseover", async (e) => {
          const a = e.target.closest("a[href]");
          if (!a) return;
          if (a.closest("header")) return;
          if (a.closest("sup")) return;
    
          aborter?.abort();
          aborter = new AbortController();
    
          if (isHomeLink(a) && a.closest(".page-two-col")) {
            preview.textContent = sessionStorage.getItem("jh_site_title") || "J—H";
            preview.classList.add("is-visible");
            positionPreview(e);
            return;
          }
    
          if (!isInternalLink(a) || !a.closest(".page-two-col")) return;
    
          try {
            const res = await fetch(a.href, { signal: aborter.signal });
            const html = await res.text();
            const text = extractPreviewText(html);
            if (!text) return;
    
            preview.textContent = text;
            preview.classList.add("is-visible");
            positionPreview(e);
          } catch {}
        });
    
        document.addEventListener("mousemove", (e) => {
          if (!preview.classList.contains("is-visible")) return;
          positionPreview(e);
        });
    
        document.addEventListener("mouseout", (e) => {
          const a = e.target.closest("a[href]");
          if (!a) return;

          if (a.contains(e.relatedTarget)) return;

          preview.classList.remove("is-visible");
          aborter?.abort();
        });

      })();
    </script>
    




    </main>

<footer class="footer" role="contentinfo">
  <p class="footer__text">
    © 2026 <span id="footer-site-title"></span><span class="footer-sep"></span>
    
      <span class="footer-msg">이 웹사이트는 <span id="footer-variant">(당분간은)</span> 제작중이다.</span>
    
  </p>

</footer>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("menu-toggle");
    const menu = document.getElementById("global-menu");
    if (!btn || !menu) return;

    const openMenu = () => {
      menu.hidden = false;
      btn.setAttribute("aria-expanded", "true");
      document.body.classList.add("menu-open");
    };

    const closeMenu = () => {
      menu.hidden = true;
      btn.setAttribute("aria-expanded", "false");
      document.body.classList.remove("menu-open");
    };

    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const expanded = btn.getAttribute("aria-expanded") === "true";
      expanded ? closeMenu() : openMenu();
    });

    document.addEventListener("click", (e) => {
      if (!menu.contains(e.target) && !btn.contains(e.target)) {
        closeMenu();
      }
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeMenu();
    });
  });
</script>


    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const currentHost = window.location.hostname;
        document
          .querySelectorAll('a[href^="http"]')
          .forEach(link => {
            const url = new URL(link.href);
            if (url.hostname !== currentHost) {
              link.setAttribute("target", "_blank");
              link.setAttribute("rel", "noopener noreferrer");
            }
          });
      });
    </script>


<script>
  const SITE_TITLES = [
    "J—H",
    "j—h",
    "Jaydashaitch",
    "제이대시에이치",
    "제이(대시)에이치",
    "JAY(DASH)AITCH",
    "JH ARCHIVE",
    "JAEHYEON LEE",
    "JAE—HYEON",
    "jay—aitch",
    "JAE(DASH)HYEON"
  ];
  
  function pickRandom(list) {
    return list[Math.floor(Math.random() * list.length)];
  }
  
  function pickRandomDifferent(list, current) {
    const pool = list.filter(item => item !== current);
    return pool.length
      ? pool[Math.floor(Math.random() * pool.length)]
      : current;
  }
  
  (function () {
    const titleEl = document.getElementById("site-title");
    const footerEl = document.getElementById("footer-site-title");
    if (!titleEl || !footerEl) return;
  
    const KEY = "jh_site_title";
  
    const renderTitle = (el, text) => {
      el.innerHTML = "";
      [...text].forEach(char => {
        const span = document.createElement("span");
        span.textContent = char;
        el.appendChild(span);
      });
    };
  
    if (!sessionStorage.getItem(KEY)) {
      sessionStorage.setItem(KEY, pickRandom(SITE_TITLES));
    }
  
    const initial = sessionStorage.getItem(KEY);
    renderTitle(titleEl, initial);
    footerEl.textContent = initial;
  
    titleEl.addEventListener("click", (e) => {
      e.preventDefault();
  
      const IS_HOME =
        window.location.pathname === "/" ||
        window.location.pathname === "/kr/";
  
      if (!IS_HOME) {
        window.location.href = titleEl.href;
        return;
      }
  
      const current = sessionStorage.getItem(KEY);
      const next = pickRandomDifferent(SITE_TITLES, current);
      sessionStorage.setItem(KEY, next);
  
      const layer = document.createElement("div");
      layer.className = "falling-layer";
      document.body.appendChild(layer);
  
      [...titleEl.children].forEach(originalSpan => {
        const rect = originalSpan.getBoundingClientRect();
  
        const span = document.createElement("span");
        span.className = "falling-char";
        span.textContent = originalSpan.textContent;
  
        span.style.left = `${rect.left}px`;
        span.style.top = `${rect.top}px`;
        span.style.animationDelay = `${Math.random() * 0.15}s`;
        span.style.animationDuration = `${1.2 + Math.random() * 1.6}s`;
  
        layer.appendChild(span);
      });
  
      titleEl.classList.add("is-switching");
  
      renderTitle(titleEl, next);
      footerEl.textContent = next;
  
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          titleEl.classList.remove("is-switching");
        });
      });
  
      setTimeout(() => {
        layer.remove();
      }, 2000);
    });
  })();
</script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const target = document.getElementById("footer-variant");
        if (!target) return;
      
        const lang = document.documentElement.lang;
      
        const variants = lang === "ko"
          ? [
              "(한동안은)",
              "(당분간은)",
              "(얼마간은)",
              "(현재로서는)",
              "(일단은)",
              "(우선은)",
              "(잠시나마)",
              "(당장까지는)",
              "(지금으로서는)",
              "(일정 기간동안은)",
              "(잠정적으로)",
              "(잠시 동안은)",
              "(지금은 계속)"
            ]
          : [
              "(for a while)",
              "(for now)",
              "(for the time being)",
              "(temporarily)",
              "(for the moment)",
              "(in the meantime)",
              "(for some time)",
              "(briefly)",
              "(until further notice)",
              "(as of now)",
              "(for a certain period)",
              "(still)",
              "(for a short while)"
            ];
      
        let current = target.textContent;
      
        const pickNext = () => {
          let next;
          do {
            next = variants[Math.floor(Math.random() * variants.length)];
          } while (next === current);
      
          current = next;
          target.textContent = next;
        };
      
        setInterval(pickNext, 1000);
      });
      </script>
  
  <script>
    (function () {
    
      const tooltip = document.createElement("div");
      tooltip.id = "menu-tooltip";
      document.body.appendChild(tooltip);
    
      const canHover = window.matchMedia("(hover: hover)").matches;
    
      function position(x, y) {
        const offset = 6;
    
        tooltip.style.left = x + offset + "px";
        tooltip.style.top = y + "px";
    
        tooltip.style.height = "";
        tooltip.style.lineHeight = "";
    
        tooltip.style.bottom = "";
        tooltip.style.transform = "";
      }
    
      function show(message, x, y) {
        tooltip.textContent = message;
        tooltip.classList.add("is-visible");
    
        position(x, y);
    
        if (!canHover) {
          clearTimeout(tooltip._timer);
    
          tooltip._timer = setTimeout(() => {
            tooltip.classList.remove("is-visible");
          }, 900);
        }
      }
    
      function getTextRect(el) {
        const range = document.createRange();
        range.selectNodeContents(el);
        return range.getBoundingClientRect();
      }
    
      if (canHover) {
    
        document.addEventListener("mouseover", (e) => {
    
          const disabled = e.target.closest(".menu-item--disabled");
          if (!disabled) return;
    
          const lang = document.documentElement.lang;
    
          show(
            lang === "ko" ? "준비중..." : "Coming soon...",
            e.clientX,
            e.clientY
          );
    
        });
    
        document.addEventListener("mousemove", (e) => {
          if (!tooltip.classList.contains("is-visible")) return;
    
          position(e.clientX, e.clientY);
        });
    
        document.addEventListener("mouseout", (e) => {
          if (!e.target.closest(".menu-item--disabled")) return;
    
          tooltip.classList.remove("is-visible");
        });
    
      } else {
    
        document.addEventListener("touchstart", (e) => {
    
          const disabled = e.target.closest(".menu-item--disabled");
          if (!disabled) return;
    
          const lang = document.documentElement.lang;
          const rect = getTextRect(disabled);
    
          show(
            lang === "ko" ? "준비중..." : "Coming soon...",
            rect.right,
            rect.top
          );
    
        });
    
      }
    
    })();
    </script>


  </body>
</html>
