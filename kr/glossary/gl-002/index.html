<!DOCTYPE html>

  
  


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>개념미술에 관한 문장들 · j-h</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    
    <!-- 0) 첫 페인트부터 폴백 감추기 (FOUT/FOIT 방지) -->
    <style>
      html:not(.wf-active):not(.wf-inactive) body { visibility: hidden; }
      html.wf-loading body { visibility: hidden; }
      html.wf-active body,
      html.wf-inactive body { visibility: visible; }
      html.wf-active body { animation: fontFadeIn .18s ease-out; }
      @keyframes fontFadeIn { from { opacity: 0 } to { opacity: 1 } }
    </style>

    <!-- 1) 폰트 커넥션 선연결 -->
    <link rel="preconnect" href="https://use.typekit.net" crossorigin>
    <link rel="preconnect" href="https://p.typekit.net" crossorigin>

    <!-- 2) Typekit 로더 -->
    <script>
      (function(d) {
        var config = { kitId: 'efe0obd', scriptTimeout: 3000, async: true },
            h = d.documentElement,
            t = setTimeout(function() {
              h.className = h.className.replace(/\bwf-loading\b/g,"") + " wf-inactive";
            }, config.scriptTimeout),
            tk = d.createElement("script"),
            f = false,
            s = d.getElementsByTagName("script")[0],
            a;
        h.className += " wf-loading";
        tk.src = "https://use.typekit.net/" + config.kitId + ".js";
        tk.async = true;
        tk.onload = tk.onreadystatechange = function() {
          a = this.readyState;
          if (f || (a && a !== "complete" && a !== "loaded")) return;
          f = true; clearTimeout(t);
          try { Typekit.load(config); } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>

    <!-- (선택) 개발 중 편의 -->
    <link rel="stylesheet" href="https://use.typekit.net/efe0obd.css">
    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <!-- 전체 2단 그리드 -->
    <div class="shell">
      <!-- 좌측: 세로 메뉴 -->
      <aside class="site-nav">
        <!-- ✅ 모바일 상단 바 (≤600px에서 보이도록 CSS 제어) -->
        <div class="nav-bar" role="navigation" aria-label="mobile top bar">
          <button class="nav-toggle" id="menu-toggle" aria-expanded="false" aria-controls="nav-menu">menu</button>
          
            <a href="&#x2F;glossary&#x2F;gl-002&#x2F;" class="lang-toggle">en</a>
          
        </div>

        <!-- ✅ 메인 메뉴: 데스크탑에서 항상 보이고, 모바일에선 토글 대상 -->
        <nav id="nav-menu" aria-label="primary">
          <a href="&#x2F;kr/">all archive</a><br>
          <a href="&#x2F;kr/works/">works</a><br>
          <a href="&#x2F;kr/about/">about</a><br>
          <a href="&#x2F;kr/contact/">contact</a><br>
        
          <!-- ⛔️ 비활성: 링크 대신 span, 클릭 불가, 회색(60%) -->
          <span class="nav-item nav-item--disabled" aria-disabled="true" title="Coming soon">shop</span>
        </nav>

        <!-- ✅ 데스크탑 전용 언어 토글: 메뉴 '아래 한 칸'에 표시 (모바일에선 CSS로 숨김) -->
        <div class="lang-toggle--desktop">
          
            <a href="&#x2F;glossary&#x2F;gl-002&#x2F;">en</a>
          
        </div>
      </aside>

      <!-- 우측: 콘텐츠 -->
      <main class="site-main">
        


<article class="page-two-col">
  
  <aside class="page-meta">
    <dl class="meta-list">
      
        <dt><h1>document no.:</h1></dt>
        <dd>5</dd>
      
  
      
        <dt><h1>category:</h1></dt>
        <dd>참조</dd>
      
  
      
  
      
  
      
  
      
        <dt><h1>author:</h1></dt>
        <dd>솔 르윗</dd>
      

      

    </dl>
  </aside>

  <div class="page-body page-content">
    
    <h1 class="display-title">
      개념미술에 관한 문장들
    </h1>
    <h2 id="daeumeun-sol-reuwisi-1969nyeone-jagseonghan-hyeondaemisule-gwanhan-munjangdeulsentences-on-conceptual-artyi-35gaji-hangmogeul-imyiro-beonyeoghan-naeyongida">*다음은 솔 르윗이 1969년에 작성한 현대미술에 관한 문장들<em>Sentences on Conceptual Art</em>의 35가지 항목을 임의로 번역한 내용이다.</h2>
<blockquote>
<ol>
<li>개념미술가는 이성주의자라기보다 신비주의자이다. 그들은 논리가 도달할 수 없는 결론에 도약한다.</li>
<li>이성적인 판단은 이성적인 판단만을 반복한다.</li>
<li>비이성적인 판단은 새로운 경험으로 이끈다.</li>
<li>형식적인 예술은 본질적으로 이성적이다.</li>
<li>비이성적인 사고는 철저하고 논리적으로 따라야 한다.</li>
<li>만약 작가가 작품을 실행하는 도중에 마음을 바꾼다면, 결과를 타협하게 되며 과거의 결과를 반복하게 된다.</li>
<li>작가의 의지는 아이디어에서 완성까지 이어지는 과정에서 부차적인 것이다. 의지의 개입은 단지 자아의 표현일 수 있다.</li>
<li>‘회화’나 ‘조각’과 같은 단어를 사용할 때, 그것은 전통 전체를 함축하며 그 전통의 수용을 암시한다. 이로 인해 예술가는 그 전통을 넘는 예술을 만들기를 주저하게 된다.</li>
<li>개념과 아이디어는 다르다. 개념은 일반적인 방향을 의미하고, 아이디어는 그 구성 요소들이다. 아이디어는 개념을 실현한다.</li>
<li>아이디어만으로도 예술 작품이 될 수 있다. 그것들은 일련의 발전 속에 있으며, 언젠가 형태를 갖출 수도 있다. 모든 아이디어가 반드시 물리적이어야 할 필요는 없다.</li>
<li>아이디어는 반드시 논리적 순서로 진행되지는 않는다. 뜻밖의 방향으로 전개될 수도 있으나, 아이디어는 다음 아이디어가 형성되기 전에 반드시 마음속에서 완결되어야 한다.</li>
<li>물리적인 예술 작품 하나마다, 실현되지 않은 수많은 변형들이 존재한다.</li>
<li>예술 작품은 작가의 마음에서 관람자의 마음으로 이어지는 매개체로 이해될 수 있다. 그러나 그것은 관람자에게 도달하지 못할 수도 있고, 작가의 마음을 벗어나지 못할 수도 있다.</li>
<li>한 예술가의 말이 또 다른 예술가에게 아이디어의 연쇄를 유발할 수 있다. 두 사람이 같은 개념을 공유할 때 그렇다.</li>
<li>어떤 형식도 본질적으로 우월하지 않기 때문에, 예술가는 단어(말이나 글)에서 물리적 실체에 이르기까지 모든 형식을 똑같이 사용할 수 있다.</li>
<li>단어가 사용되고 그것이 예술에 대한 아이디어에서 비롯되었다면, 그것은 문학이 아니라 예술이다. 숫자는 수학이 아니다.</li>
<li>예술과 관련되어 있으며 예술의 관습 안에 속한다면, 모든 아이디어는 예술이다.</li>
<li>우리는 대개 현재의 관습을 적용해 과거의 예술을 이해하려 하기 때문에, 결국 과거의 예술을 오해하게 된다.</li>
<li>예술의 관습은 예술 작품에 의해 변화한다.</li>
<li>성공적인 예술은 우리의 관습에 대한 이해를 바꾸며, 우리의 인식을 변화시킨다.</li>
<li>아이디어에 대한 인식은 새로운 아이디어로 이어진다.</li>
<li>작가는 자신의 예술을 상상할 수도 없고, 완성되기 전까지 그것을 인식할 수도 없다.</li>
<li>한 예술가는 어떤 예술 작품을 오해(작가와 다르게 이해)할 수 있으나, 그 오해 자체가 새로운 사고의 연쇄를 불러일으킬 수 있다.</li>
<li>인식은 주관적이다.</li>
<li>작가는 자신의 예술을 반드시 이해하지는 못한다. 그의 인식이 다른 이보다 낫지도, 못하지도 않다.</li>
<li>어떤 예술가는 타인의 예술을 자기 작품보다 더 잘 인식할 수도 있다.</li>
<li>작품의 개념은 작품의 물질 혹은 그것이 만들어지는 과정에 관련될 수 있다.</li>
<li>작가의 마음속에 작품의 아이디어와 최종 형태가 결정되면, 그 과정은 맹목적으로 수행된다. 작가가 상상하지 못한 많은 부수적인 효과들이 생기고, 그것들은 새로운 작품의 아이디어로 사용될 수 있다.</li>
<li>그 과정은 기계적이어야 하며, 방해받지 않아야 한다. 그것은 자신의 경로를 따라야 한다.</li>
<li>예술 작품에는 많은 요소가 포함되어 있다. 그중 가장 중요한 것은 가장 명백한 것이다.</li>
<li>한 예술가가 일련의 작품들에서 같은 형식을 사용하면서 재료만 바꾼다면, 사람들은 그 작가의 개념이 재료에 있었던 것이라 여길 것이다.</li>
<li>진부한 아이디어는 아름다운 실행으로도 구제되지 않는다.</li>
<li>좋은 아이디어는 망치기 어렵다.</li>
<li>작가가 자신의 기술을 지나치게 잘 익히면, 그 결과는 매끈하기만 한 예술이 된다.</li>
<li>이 문장들은 예술에 대해 말하고 있지만, 예술 그 자체는 아니다.</li>
</ol>
</blockquote>


    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const content = document.querySelector('.page-content');
        if (!content) return;
      
        /* ---------------------------------------------
         * 1) 흩어진 각주 아이템을 .footnotes 컨테이너로 래핑
         *    - 대상: .footnote-definition, li[id^="fn"]
         *    - 이미 .footnotes가 있으면 건너뜀
         * --------------------------------------------- */
        let wrap = content.querySelector('.footnotes');
        if (!wrap) {
          const items = Array.from(
            content.querySelectorAll('.footnote-definition, li[id^="fn"]')
          );
          if (items.length) {
            const parent = items[0].parentElement;
            const group = items.filter(el => el.parentElement === parent);
            if (group.length) {
              wrap = document.createElement('div');
              wrap.className = 'footnotes';
              wrap.setAttribute('role', 'doc-endnotes');
              wrap.setAttribute('aria-label', 'Footnotes');
              parent.insertBefore(wrap, group[0]);
              group.forEach(el => wrap.appendChild(el));
            }
          }
        }
      
        /* ---------------------------------------------
         * 2) 각주 본문(p) 내 URL을 <a>로 자동 변환
         *    - 호환: http/https/www
         *    - 말미의 쉼표/마침표/괄호 등은 제외
         * --------------------------------------------- */
        if (wrap) {
          const URL_RE = /((?:https?:\/\/|www\.)[^\s<>()]+?)(?=[\s<>()]|$)/g;
      
          wrap.querySelectorAll('.footnote-definition > p, li[id^="fn"] > p')
            .forEach(p => {
              if (p.dataset.autolinked === '1') return;
              p.innerHTML = p.innerHTML.replace(URL_RE, (m, url) => {
                const href = url.startsWith('http') ? url : `https://${url}`;
                return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
              });
              p.dataset.autolinked = '1';
            });
      
          // 안전: 링크 rel 보정
          wrap.querySelectorAll('a').forEach(a => {
            const rel = (a.getAttribute('rel') || '').split(/\s+/);
            ['noopener','noreferrer'].forEach(tok => { if (!rel.includes(tok)) rel.push(tok); });
            a.setAttribute('rel', rel.join(' ').trim());
          });
        }
      });
      </script>
      
  </div>

</article>


      </main>
    </div>

    <!-- Footer -->
    <footer class="site-footer" role="contentinfo" aria-label="site footer">
      <p class="site-footer__text">
        j-h, jaydashaitch, online archive of jae hyeon lee. ©2025 jaehyeon lee
      </p>
      <p class="site-footer__text--mobile">
        j-h, ©2025 jaehyeon lee
      </p>
    </footer>

    <!-- Hangul span 래핑 스크립트 -->
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const HANGUL_RE = /([\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3]+)/g;
        const SKIP_SELECTOR = 'pre, code, kbd, samp, script, style';
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !HANGUL_RE.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
              let p = node.parentNode;
              while (p && p !== document.body) {
                if (p.matches && p.matches(SKIP_SELECTOR)) return NodeFilter.FILTER_REJECT;
                p = p.parentNode;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        const texts = [];
        let n;
        while (n = walker.nextNode()) texts.push(n);
        for (const text of texts) {
          const span = document.createElement('span');
          span.innerHTML = text.nodeValue.replace(HANGUL_RE, '<span class="han">$1</span>');
          text.parentNode.replaceChild(span, text);
        }
      });
    </script>

    <!-- ✅ Mobile Menu Script -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const btn = document.getElementById("menu-toggle");
        const menu = document.getElementById("nav-menu");
        if (!btn || !menu) return;

        function closeMenu() {
          menu.classList.remove("open");
          btn.setAttribute("aria-expanded", "false");
        }

        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.toggle("open");
          btn.setAttribute("aria-expanded", String(isOpen));
        });

        document.addEventListener("click", (e) => {
          if (!menu.contains(e.target) && !btn.contains(e.target)) closeMenu();
        });

        window.addEventListener("resize", () => {
          if (window.innerWidth > 600) closeMenu();
        });
      });
    </script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (window.__FN_WIRED__) return;
    window.__FN_WIRED__ = true;
  
    /* =========================
       설정값
       ========================= */
    const SCROLL_MS   = 300;   // 부드럽지만 빠르게
    const HL_IN_MS    = 200;   // 페이드 인
    const HL_OUT_MS   = 700;   // 페이드 아웃(느리게)
    const HL_HOLD_MS  = 800;   // 유지 시간(짧게 유지 후 서서히 사라짐)
  
/* =========================
   스크롤 유틸 (컨테이너 대응, quintic S-curve + out-bias)
   ========================= */
   const isScrollable = (el) => {
  if (!el) return false;
  const s = getComputedStyle(el);
  const oy = s.overflowY;
  return (oy === "auto" || oy === "scroll") && el.scrollHeight > el.clientHeight;
};

const getScrollContainer = (el) => {
  let node = el.parentElement;
  while (node && node !== document.body && node !== document.documentElement) {
    if (isScrollable(node)) return node;
    node = node.parentElement;
  }
  return document.scrollingElement || document.documentElement || document.body;
};

/* =========================
   스크롤 애니메이션 (quintic S-curve + out-bias)
   - 부드러운 시작, 끈적한 감속
   ========================= */
const easeInOutSticky = (t) => {
  // Quintic smoothstep (C2 연속, S-curve)
  const t2 = t * t, t3 = t2 * t, t4 = t2 * t2, t5 = t4 * t;
  const base = 6 * t5 - 15 * t4 + 10 * t3; // 기본 S-curve
  const OUT_BIAS = 1.12; // 1.0~1.2 권장 (↑ = 더 끈적한 감속)
  return 1 - Math.pow(1 - base, OUT_BIAS);
};

const scrollToTarget = (container, target, ms = SCROLL_MS, offsetY = 0) =>
  new Promise((resolve) => {
    const containerIsDoc =
      container === document.scrollingElement ||
      container === document.documentElement ||
      container === document.body;

    const containerRect = containerIsDoc
      ? { top: 0 }
      : container.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    const start = containerIsDoc
      ? window.pageYOffset || document.documentElement.scrollTop
      : container.scrollTop;

    const targetY = start + (targetRect.top - containerRect.top) + offsetY;

    if (ms <= 0) {
      if (containerIsDoc) window.scrollTo(0, targetY);
      else container.scrollTop = targetY;
      resolve();
      return;
    }

    const startTime = performance.now();
    const step = (now) => {
      const t = Math.min(1, (now - startTime) / ms);
      const eased = easeInOutSticky(t);
      const y = start + (targetY - start) * eased;

      if (containerIsDoc) window.scrollTo(0, y);
      else container.scrollTop = y;

      if (t < 1) {
        requestAnimationFrame(step);
      } else {
        if (containerIsDoc) window.scrollTo(0, targetY);
        else container.scrollTop = targetY;
        resolve();
      }
    };

    requestAnimationFrame(step);
  });

  
    /* =========================
       하이라이트 (빠른 IN → 유지 → 느린 OUT)
       ========================= */
    const highlight = (host, hold = HL_HOLD_MS) => {
      if (!host) return;
      host.classList.add('fn-hl');  // 초기 상태(투명) + 트랜지션 규칙
      // 다음 프레임에 ON
      requestAnimationFrame(() => {
        host.style.setProperty('--fn-hl-in',  `${HL_IN_MS}ms`);
        host.style.setProperty('--fn-hl-out', `${HL_OUT_MS}ms`);
        host.classList.add('is-on');           // 빠르게 켜짐
        setTimeout(() => {
          host.classList.add('is-fading');     // 느리게 꺼짐
          host.classList.remove('is-on');
          setTimeout(() => host.classList.remove('fn-hl', 'is-fading'), HL_OUT_MS + 30);
        }, hold);
      });
    };
  
    /* =========================
       매핑: 본문 참조 ↔ 각주 블록
       ========================= */
    const allIds = new Set([...document.querySelectorAll('[id]')].map(el => el.id));
    const bodyLinks = [...document.querySelectorAll('.page-content a[href^="#"]')]
      .filter(a => !a.closest('.footnote-definition') && !a.closest('.footnotes'));
  
    const footnoteIds = new Set(
      bodyLinks
        .map(a => (a.getAttribute('href') || '').slice(1))
        .filter(id => id && allIds.has(id))
    );
  
    const getFootnoteBlock = (id) => {
      const el = document.getElementById(id);
      return el
        ? (el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el)
        : null;
    };
  
    const backMap = new Map();
    bodyLinks
      .filter(a => footnoteIds.has((a.getAttribute('href') || '').slice(1)))
      .forEach(a => {
        const id = a.getAttribute('href').slice(1);
        const sup = a.closest('sup[id^="fnref"]') || a.closest('sup');
        const target = sup || a;
        if (!target.id) {
          let base = `fnref-auto-${id}`, i = 1, uid = base;
          while (document.getElementById(uid)) uid = `${base}-${i++}`;
          target.id = uid;
        }
        backMap.set(id, target.id);
      });
  
    /* =========================
       이벤트: 본문 → 각주
       ========================= */
    document.addEventListener('click', async (e) => {
      const ref = e.target.closest('.page-content a[href^="#"]');
      if (!ref || ref.closest('.footnote-definition') || ref.closest('.footnotes')) return;
  
      const hash = ref.getAttribute('href') || '';
      if (!hash.startsWith('#')) return;
  
      const id = hash.slice(1);
      if (!footnoteIds.has(id)) return;
  
      e.preventDefault();
      const fnBlock = getFootnoteBlock(id);
      if (!fnBlock) return;
  
      const container = getScrollContainer(fnBlock);
      await scrollToTarget(container, fnBlock, SCROLL_MS, 0);
      history.pushState(null, '', `#${id}`);
      highlight(fnBlock, HL_HOLD_MS);
    });
  
    /* =========================
       이벤트: 각주 → 본문
       ========================= */
    document.addEventListener('click', async (e) => {
      const a = e.target.closest('a');
      if (a) {
        const href = a.getAttribute('href') || '';
        if (href && !href.startsWith('#')) return; // 외부 링크는 방해하지 않음
      }
  
      let node = e.target.closest('[id]');
      while (node) {
        const id = node.id;
        if (footnoteIds.has(id)) {
          const backId = backMap.get(id);
          if (backId) {
            e.preventDefault();
            const backEl = document.getElementById(backId) || document.querySelector(`a[href="#${id}"]`);
            if (!backEl) return;
            const container = getScrollContainer(backEl);
            await scrollToTarget(container, backEl, SCROLL_MS, 0);
            history.pushState(null, '', `#${backId}`);
            highlight(backEl, HL_HOLD_MS);
          }
          return;
        }
        node = node.parentElement;
      }
    });
  
    /* =========================
       해시 진입/변경 시 하이라이트
       ========================= */
    const flashFromHash = async () => {
      const id = location.hash.slice(1);
      if (!id) return;
      const el = document.getElementById(id);
      if (!el) return;
      const target = el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el;
      const container = getScrollContainer(target);
  
      // 뷰포트 안에 대략 보이는지 검사
      const viewTop = (container === document.scrollingElement || container === document.documentElement || container === document.body)
        ? 0
        : container.getBoundingClientRect().top;
      const r = target.getBoundingClientRect();
      const inView = (r.top - viewTop) >= 0 && (r.bottom - viewTop) <= (container.clientHeight || window.innerHeight);
  
      if (!inView) await scrollToTarget(container, target, SCROLL_MS, 0);
      highlight(target, HL_HOLD_MS);
    };
  
    window.addEventListener('hashchange', () => setTimeout(flashFromHash, 30));
    if (location.hash) setTimeout(flashFromHash, 60);
  });
  </script>
  
  

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.page-content ol > li').forEach(li => {
        // 이미 래퍼가 있으면 생략
        if (li.querySelector(':scope > .li-body')) return;
    
        const body = document.createElement('span'); // inline semantics 유지
        body.className = 'li-body';
    
        // 숫자 마커(::before) 외 모든 노드를 li-body로 이동
        while (li.firstChild) body.appendChild(li.firstChild);
        li.appendChild(body);
      });
    });
    </script>


<script>
  document.addEventListener("DOMContentLoaded", function() {
    const currentHost = window.location.hostname;
    const links = document.querySelectorAll('a[href^="http"]');
  
    links.forEach(link => {
      const url = new URL(link.href);
      if (url.hostname !== currentHost) {
        link.setAttribute("target", "_blank");
        link.setAttribute("rel", "noopener noreferrer");
      }
    });
  });
  </script>


  
  </body>
</html>
