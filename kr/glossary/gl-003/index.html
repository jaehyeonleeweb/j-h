<!DOCTYPE html>


  


<script>
  console.log("current_path:", "/kr/glossary/gl-003/");
</script>

<script>
  console.log("lang:", "kr");
  console.log("section.lang:", "(no section)");
  console.log("page.lang:", "kr");
</script>


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>프로-프로그래마틱, 제이대시에이치</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">

    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <header class="header" role="banner">
      <button
        class="menu-toggle"
        id="menu-toggle"
        aria-expanded="false"
        aria-controls="global-menu"
      >
       
          메뉴
       
      </button>

      <a href="&#x2F;kr/" class="site-title" id="site-title"></a>

      <span class="lang-toggle" data-lang="kr">
        
        <span class="ko">한</span>
        <span class="sep"> / </span>
        
          <a href="&#x2F;glossary&#x2F;gl-003&#x2F;" class="en">EN</a>
        
        
      </span>
      
    </header>

    <nav
      id="global-menu"
      class="global-menu"
      aria-label="primary"
      hidden
    >
      
        <a href="&#x2F;kr/allarchive/">모든 아카이브</a>
        
        <a href="&#x2F;kr/about/">이 웹에 대하여</a>
        <a href="&#x2F;kr/contact/">연락처</a>
        <span class="menu-item--disabled" aria-disabled="true">구매</span>
      
    </nav>

    <main id="content">
      

<article class="page-two-col" role="article">

  <aside class="page-meta" role="complementary">

    <div class="meta-block meta-title">
      <strong>프로-프로그래마틱</strong>
    </div>

    <div class="meta-block meta-data">

      
        <div class="meta-line">
          
            문서 번호 → [11]
          
        </div>
      
    
      
        <div class="meta-line">
          
            카테고리 → [참조]
          
        </div>
      
    
      
      <div class="meta-line">
        
          저자 →
        
    
        
        
          [파울 그레딩거]
        
      </div>
    
    
    
    
    
    
    
    
    
    

      
  
  
    
    </div>
    

    
    

    
    <div class="meta-block meta-notes">
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-1"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">1</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            파울 그레딩거, 「프로-프로그래마틱」, 카를 게르스트너 저, 박재용 옮김, 『디자이닝 프로그램스』 안그라픽스, 2014, 2쪽.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-2"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">2</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            같은 책, 3쪽.
          </span>
        </div>
      
    </div>
    
    

  </aside>

  <div class="page-body page-content">

    <blockquote>
<p>⋯ ‘디자이닝 프로그램스’는 배열을 위해 규칙을 창안하는 것을 뜻할 수도 있다. 디자이너는 화학 반응과 마찬가지로 일종의 공식을 참조하고 일군의 새로운 조합을 찾고자 애써야 한다. 여기에서 가장 중요한 것은 바로 공식이다. 공식은 형태를 창출한다. 여러가지 형태를 만들어내는 것이다. 예컨대 이러한 개념을 따르는 시의 경우 공식이 존재한다. 여기에서 전통적인 언어 구조는 해체된다. 문법은 존재하지 않는다. 구문도 없다. 각각의 단어가 구성요소로 존재한다. 단어들은 결합가가 풀린 채 자유로운 상태로 나열된다. 이 게임의 규칙은 순열이며, 이렇게 발생하는 시를 배열이라고 부른다. 배열은 일종의 시적 프로그램이다.<sup class="footnote-reference" id="fr-1-1"><a href="#fn-1">1</a></sup><br />
<br><br>
⋯ 이보다 더욱 자명하며, 따라서 의식적으로는 잘 떠오르지 않는 프로그램이 있다. 바로 레시피라는 공식이다. 우선, 레시피는 여러 요소를 열거한다. 예컨대 감자, 우유, 물, 소금, 버터 등. 다음으로는 재료를 손질한다. 껍질 벗기기, 자르기, 끓이기, 받쳐서 물 빼기, 젓기⋯. 그 결과 으깬 감자 요리가 완성된다. 레시피는 곧 프로그램이다. 이는 매우 자명한 사실이다. 그러나 이러한 방식으로 이뤄지는 여러 프로그램을 해석하는 건 어려운 일이다. 또한 실제로 어려움이 시작되는 것은 프로그램을 디자인하는 과정에서다. 그런 점에서 이를 기술, 즉 조리술이라고 부른다. 그럼에도 여전히 조리해야 할 메뉴가 모인 총체가 존재한다. 하나의 프로그램에 또 다른 프로그램이 겹쳐지는 셈인데, 이것이 모인 한 권의 악보가 바로 요리 서적이다.<sup class="footnote-reference" id="fr-2-1"><a href="#fn-2">2</a></sup></p>
</blockquote>
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn-1">
<p>파울 그레딩거, 「프로-프로그래마틱」, 카를 게르스트너 저, 박재용 옮김, 『디자이닝 프로그램스』 안그라픽스, 2014, 2쪽. <a href="#fr-1-1">↩</a></p>
</li>
<li id="fn-2">
<p>같은 책, 3쪽. <a href="#fr-2-1">↩</a></p>
</li>
</ol>
</section>


  </div>

</article>

<div id="image-viewer" aria-hidden="true">
  <button class="viewer-close" aria-label="Close">×</button>
  <button class="viewer-prev" aria-label="Previous">←</button>
  <img class="viewer-image" alt="" />
  <button class="viewer-next" aria-label="Next">→</button>
</div>

<div id="link-preview" aria-hidden="true"></div>


<script>
  (function () {
  
    function isVisible(el) {
      return !!(el && el.offsetParent !== null);
    }
  
    function isInViewport(el) {
      if (!el) return false;
      const r = el.getBoundingClientRect();
      return r.bottom > 0 && r.top < window.innerHeight;
    }
  
    function scrollToRef(el, block) {
      if (!el) return;
      el.scrollIntoView({
        behavior: "smooth",
        block: block
      });
    }
  
    function scrollDocumentToRevealMeta() {
      window.scrollTo({
        top: document.documentElement.scrollHeight,
        behavior: "smooth"
      });
    }
  
    function setActiveFootnote(id) {
      history.pushState(null, "", "#" + id);
  
      document.querySelectorAll(".meta-note").forEach(el => {
        el.classList.toggle("is-active", el.dataset.fnid === id);
      });
  
      document.querySelectorAll(".footnotes-list li[id]").forEach(el => {
        el.classList.toggle("is-active", el.id === id);
      });
    }
  
    const mqDesktop = window.matchMedia("(min-width: 600px)");
  
    document.addEventListener("click", function (e) {
  
      const meta = e.target.closest(".meta-note[data-fnid]");
      if (meta) {
        if (e.target.closest("a")) return;
  
        const id = meta.dataset.fnid;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const def = e.target.closest(".footnotes-list li[id]");
      if (def) {
        if (e.target.closest("a")) return;
  
        const id = def.id;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const refLink = e.target.closest(".footnote-reference a[href^='#']");
      if (!refLink) return;
  
      e.preventDefault();
  
      const id = refLink.getAttribute("href").slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
  
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
    document.addEventListener("DOMContentLoaded", function () {
      if (!location.hash.startsWith("#")) return;
  
      const id = location.hash.slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
  })();
  </script>  
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const PUNCTS = `"'\u2018\u201C([{‹«〈《「『`;
    
        const targets = document.querySelectorAll(
  '.page-meta .meta-title, \
   .page-meta .meta-line, \
   .page-body .page-content p, \
   .page-body .page-content li'
);

    
      targets.forEach(el => {
        const text = (el.textContent || '').trimStart();
        if (!text) return;
    
        const firstChar = text[0];
        if (!PUNCTS.includes(firstChar)) return;
    
        el.classList.add('hang-punct');
      });
    });
    </script>
    
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const superscriptMap = {
          "0": "⁰",
          "1": "¹",
          "2": "²",
          "3": "³",
          "4": "⁴",
          "5": "⁵",
          "6": "⁶",
          "7": "⁷",
          "8": "⁸",
          "9": "⁹"
        };
      
        document
          .querySelectorAll("sup.footnote-reference a")
          .forEach(el => {
            const text = el.textContent.trim();
      
            if (!/^\d+$/.test(text)) return;
      
            const superscript = [...text]
              .map(d => superscriptMap[d] || d)
              .join("");
      
            el.textContent = superscript;
            el.setAttribute("aria-label", `Footnote ${text}`);
          });
      });
      </script>
      
      <script>
        (function () {
          const root = document.querySelector(".page-body.page-content");
          if (!root) return;

          root.querySelectorAll("blockquote ol > li").forEach(li => {
            if (li.querySelector(":scope > .li-body")) return;

            const body = document.createElement("span");
            body.className = "li-body";

            const nodes = Array.from(li.childNodes);

            nodes.forEach(node => {
              if (
                node.nodeType === Node.ELEMENT_NODE ||
                (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "")
              ) {
                body.appendChild(node);
              }
            });

            li.appendChild(body);
          });
        })();
        </script>


        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const root = document.querySelector(".page-body.page-content");
            if (!root) return;
          
            root.querySelectorAll("p > strong").forEach(strong => {
              const parent = strong.parentElement;
              if (parent && parent.classList.contains("centered-strong")) return;
          
              const wrapper = document.createElement("span");
              wrapper.className = "centered-strong";
          
              parent.replaceChild(wrapper, strong);
              wrapper.appendChild(strong);
            });
          });
          </script>
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const isMobile = window.matchMedia("(max-width: 600px)").matches;
      
      const images = Array.from(
        document.querySelectorAll(".page-body.page-content figure img")
      );
    
      if (!images.length) return;
    
      const viewer = document.getElementById("image-viewer");
      const viewerImg = viewer.querySelector(".viewer-image");
      const btnClose = viewer.querySelector(".viewer-close");
      const btnPrev = viewer.querySelector(".viewer-prev");
      const btnNext = viewer.querySelector(".viewer-next");
    
      let currentIndex = 0;
    
      function openViewer(index) {
        currentIndex = index;
        viewerImg.src = images[currentIndex].src;
        viewer.classList.add("is-open");
        viewer.setAttribute("aria-hidden", "false");
      }
    
      function closeViewer() {
        viewer.classList.remove("is-open");
        viewer.setAttribute("aria-hidden", "true");
      }
    
      function prev() {
        if (currentIndex > 0) openViewer(currentIndex - 1);
      }
    
      function next() {
        if (currentIndex < images.length - 1) openViewer(currentIndex + 1);
      }
    
      images.forEach((img, i) => {
        img.style.cursor = "zoom-in";
        img.addEventListener("click", () => openViewer(i));
      });
    
      if (!isMobile) {
      btnClose.addEventListener("click", closeViewer);
      btnPrev.addEventListener("click", prev);
      btnNext.addEventListener("click", next);
      }
      if (isMobile) {
      viewer.addEventListener("click", closeViewer);
      } else {
      viewerImg.addEventListener("click", closeViewer);
      viewer.addEventListener("click", e => {
      if (e.target === viewer) {
      closeViewer();
      }
      });
    }
        
      if (isMobile) {
        let startX = 0;
        let startY = 0;

        viewer.addEventListener("touchstart", e => {
          const t = e.touches[0];
          startX = t.clientX;
          startY = t.clientY;
        }, { passive: true });

        viewer.addEventListener("touchend", e => {
          const t = e.changedTouches[0];
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;

          if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) {
              prev();
            } else {
              next();
            }
          }
        });
      }

      document.addEventListener("keydown", e => {
        if (!viewer.classList.contains("is-open")) return;
        if (e.key === "Escape") closeViewer();
        if (e.key === "ArrowLeft") prev();
        if (e.key === "ArrowRight") next();
      });
    });
    </script>

<script>
  (function () {
    if (!window.matchMedia("(min-width: 601px)").matches) return;
  
    const preview = document.createElement("div");
    preview.id = "link-preview";
    document.body.appendChild(preview);
  
    let aborter = null;
  
    function isInternalLink(a) {
      if (!a || !a.href) return false;
      try {
        return new URL(a.href).origin === location.origin;
      } catch {
        return false;
      }
    }
  
    function extractPreviewText(html) {
        const doc = new DOMParser().parseFromString(html, "text/html");

        const body = doc.querySelector(".page-body");
        if (!body) return "";

        body.querySelectorAll(
          "figure, img, pre, code, table, script, style, \
          .footnotes, .footnotes-list, aside"
        ).forEach(el => el.remove());

        body.querySelectorAll("sup").forEach(el => el.remove());

        const candidates = Array.from(
          body.querySelectorAll("p, li")
        )
          .map(el =>
            el.textContent
              .replace(/\s+/g, " ")
              .trim()
          )
          .filter(text => text.length > 0);

        if (!candidates.length) return "";

        return candidates[0];
      }
  
    function positionPreview(e) {
      const offset = 14;
      const maxX = window.innerWidth  - preview.offsetWidth  - 8;
      const maxY = window.innerHeight - preview.offsetHeight - 8;
  
      preview.style.left = Math.min(e.clientX + offset, maxX) + "px";
      preview.style.top  = Math.min(e.clientY + offset, maxY) + "px";
    }
  
    document.addEventListener("mouseover", async (e) => {
      const a = e.target.closest("a[href]");
      if (!a || !isInternalLink(a)) return;
      
      if (a.closest("sup")) return;
      
      aborter?.abort();
      aborter = new AbortController();
  
      try {
        const res = await fetch(a.href, { signal: aborter.signal });
        const html = await res.text();
        const text = extractPreviewText(html);
  
        if (!text) return;
  
        preview.textContent = text;
        preview.classList.add("is-visible");
        positionPreview(e);
      } catch {
      }
    });
  
    document.addEventListener("mousemove", (e) => {
      if (!preview.classList.contains("is-visible")) return;
      positionPreview(e);
    });
  
    document.addEventListener("mouseout", (e) => {
      if (!e.target.closest("a[href]")) return;
      preview.classList.remove("is-visible");
      aborter?.abort();
    });
  })();
  </script>
  
  
    



    </main>

<footer class="footer" role="contentinfo">
  <p class="footer__text">
    © 2026 <span id="footer-site-title"></span><span class="footer-sep"></span>
    
      <span class="footer-msg">이 웹사이트는 <span id="footer-variant">(당분간은)</span> 제작중이다.</span>
    
  </p>

</footer>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("menu-toggle");
    const menu = document.getElementById("global-menu");
    if (!btn || !menu) return;

    const openMenu = () => {
      menu.hidden = false;
      btn.setAttribute("aria-expanded", "true");
      document.body.classList.add("menu-open");
    };

    const closeMenu = () => {
      menu.hidden = true;
      btn.setAttribute("aria-expanded", "false");
      document.body.classList.remove("menu-open");
    };

    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const expanded = btn.getAttribute("aria-expanded") === "true";
      expanded ? closeMenu() : openMenu();
    });

    document.addEventListener("click", (e) => {
      if (!menu.contains(e.target) && !btn.contains(e.target)) {
        closeMenu();
      }
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeMenu();
    });
  });
</script>


    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const currentHost = window.location.hostname;
        document
          .querySelectorAll('a[href^="http"]')
          .forEach(link => {
            const url = new URL(link.href);
            if (url.hostname !== currentHost) {
              link.setAttribute("target", "_blank");
              link.setAttribute("rel", "noopener noreferrer");
            }
          });
      });
    </script>

    <script>
      const SITE_TITLES = [
      "J—H",
      "j—h",
      "Jaydashaitch",
      "제이대시에이치",
      "제이(대시)에이치",
      "JAY(DASH)AITCH",
      "JH ARCHIVE",
      "JAEHYEON LEE",
      "JAE—HYEON",
      "jay—aitch",
      "JAE(DASH)HYEON"
      ];

      function pickRandom(list) {
        return list[Math.floor(Math.random() * list.length)];
      }

      function pickRandomDifferent(list, current) {
        const pool = list.filter(item => item !== current);
        return pool.length
          ? pool[Math.floor(Math.random() * pool.length)]
          : current;
      }

      (function () {
        const titleEl = document.getElementById("site-title");
        const footerEl = document.getElementById("footer-site-title");
        if (!titleEl || !footerEl) return;

        const KEY = "jh_site_title";

        const applyTitle = (value) => {
          titleEl.textContent = value;
          footerEl.textContent = value;
        };

        if (!sessionStorage.getItem(KEY)) {
          sessionStorage.setItem(KEY, pickRandom(SITE_TITLES));
        }

        applyTitle(sessionStorage.getItem(KEY));

        titleEl.addEventListener("click", (e) => {
          e.preventDefault();

          const current = sessionStorage.getItem(KEY);
          const next = pickRandomDifferent(SITE_TITLES, current);

          sessionStorage.setItem(KEY, next);
          applyTitle(next);

          setTimeout(() => {
            window.location.href = titleEl.href;
          }, 80);
        });
      })();
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const target = document.getElementById("footer-variant");
        if (!target) return;
      
        const lang = document.documentElement.lang;
      
        const variants = lang === "ko"
          ? [
              "(한동안은)",
              "(당분간은)",
              "(얼마간은)",
              "(현재로서는)",
              "(일단은)",
              "(우선은)",
              "(잠시나마)",
              "(당장까지는)",
              "(지금으로서는)",
              "(일정 기간동안은)",
              "(잠정적으로)",
              "(잠시 동안은)",
              "(지금은 계속)"
            ]
          : [
              "(for a while)",
              "(for now)",
              "(for the time being)",
              "(temporarily)",
              "(for the moment)",
              "(in the meantime)",
              "(for some time)",
              "(briefly)",
              "(until further notice)",
              "(as of now)",
              "(for a certain period)",
              "(still)",
              "(for a short while)"
            ];
      
        let current = target.textContent;
      
        const pickNext = () => {
          let next;
          do {
            next = variants[Math.floor(Math.random() * variants.length)];
          } while (next === current);
      
          current = next;
          target.textContent = next;
        };
      
        setInterval(pickNext, 1000);
      });
      </script>
  
  </body>
</html>
