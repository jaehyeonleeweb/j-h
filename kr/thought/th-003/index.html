<!DOCTYPE html>


  


<script>
  console.log("current_path:", "/kr/thought/th-003/");
</script>

<script>
  console.log("lang:", "kr");
  console.log("section.lang:", "(no section)");
  console.log("page.lang:", "kr");
</script>


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>듀오스페이스 글꼴에 대하여, 제이대시에이치</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">

    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <header class="header" role="banner">
      <button
        class="menu-toggle"
        id="menu-toggle"
        aria-expanded="false"
        aria-controls="global-menu"
      >
       
          메뉴
       
      </button>

      <a href="&#x2F;kr/" class="site-title" id="site-title"></a>

      <span class="lang-toggle" data-lang="kr">
        
        <span class="ko">한</span>
        <span class="sep"> / </span>
        
          <a href="&#x2F;thought&#x2F;th-003&#x2F;" class="en">EN</a>
        
        
      </span>
      
    </header>

    <nav
      id="global-menu"
      class="global-menu"
      aria-label="primary"
      hidden
    >
      
        <a href="&#x2F;kr/allarchive/">모든 아카이브</a>
        
        <a href="&#x2F;kr/about/">이 웹에 대하여</a>
        <a href="&#x2F;kr/contact/">연락처</a>
        <span class="menu-item--disabled" aria-disabled="true">구매</span>
      
    </nav>

    <main id="content">
      

<article class="page-two-col" role="article">

  <aside class="page-meta" role="complementary">

    <div class="meta-block meta-title">
      <strong>듀오스페이스 글꼴에 대하여</strong>
    </div>

    <div class="meta-block meta-data">

      
        <div class="meta-line">
          
            문서 번호 → [20]
          
        </div>
      
    
      
        <div class="meta-line">
          
            카테고리 → [생각]
          
        </div>
      
    
      
    
    
    
    
    
    
    
    
    
      <div class="meta-line">
        
          날짜 →
        
    
        
        
          [2026년 2월]
        
      </div>
    

      
  
  
    
    </div>
    

    
    

    
    <div class="meta-block meta-notes">
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-1"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">1</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            웹 리뉴얼(2026)에 대한 정보는 <a href="/kr/about/about/">이 웹에 대하여</a>를 참고
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-2"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">2</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            문제가 있더라도 비교적 쉽게 조정이 가능하다. 어찌됐건 출판물의 판형은 움직이지 않으니까.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-3"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">3</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            웹을 공부하기 시작한 지 얼마 되지 않은 터라, 아직 다른 대안은 잘 떠오르지 않는다. ’디지털 환경에서 효과적인 타이포그래피‘에 대해 앞으로 계속 고민해볼 예정이다.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-4"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">4</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            CJK는 China, Japan, Korea의 문자 환경을 묶어 부르는 타이포그래피 용어다. 서구권에서는 이를 동아시아 타이포그래피(East Asian Typography)라고 부르기도 하는데, 이는 너무 넓은 지리적 범위를 포함하므로 ‘동북아시아’ 내지는 ‘한자 문화권’으로 번역하는 편이 적절할 것이다. 하지만 이것도 정확하지는 않다. CJK는 중국, 일본, 한국의 문자환경을 의미하는 하나의 고유명사에 가깝기 때문이다. 따라서 이 문서에서는 직관적인 의미는 다소 떨어지지만 보다 정확한 용어인 CJK를 번역하지 않고 그대로 쓰기로 한다.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-5"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">5</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            이 문서에서 ‘쓰기 관습’은 ‘글을 쓰는 총체적인 관습과 양식’을 통틀어 의미하는 단어로 사용된다. ‘쓰기 체계’라는 단어를 사용하려고 했지만 이는 타이포그래피 용어로 ‘Writing System’에 대응될 수 있어 피하고자 했다. ‘Writing System’은 알파벳이나 가나 등 언어 단위의 문자 체계를 의미한다.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-6"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">6</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            노토 산스, 산돌 고딕 등의 글자 모두 가로너비가 세로의 높이보다 좁다. 때문에 노토 산스를 기반으로 한 <a href="/kr/works/project/pr-005/">제이에이치 웹 듀오</a> 또한 전각 단위를 정사각형이 아닌 직사각형으로 기준 삼고 있다.
          </span>
        </div>
      
    </div>
    
    

  </aside>

  <div class="page-body page-content">

    <p><strong>1. ‘듀오스페이스 글꼴’이라는 용어에 대하여</strong><br></p>
<p><a href="/kr/web-document/wd-002/">지난 웹</a>을 리뉴얼하며,<sup class="footnote-reference" id="fr-1-1"><a href="#fn-1">1</a></sup> 나는 문제적 용어 ‘듀오스페이스’를 마주하게 되었다. 정확히는 <a href="/kr/works/project/pr-005/">제이에이치 웹 듀오</a>를 제작하는 와중에 말이다. <a href="/kr/web-document/wd-002/">지난 웹</a>의 섞어짜기는 여러모로 성가신 과제였다. 나는 <a rel="external" href="https://j-h-a-r-c-h-i-v-e.com/kr/">이 웹</a>의 모든 문서를 한글과 영문으로 두 벌씩 작성하고 있다. 이 같은 제약은 필연적으로 다국어 타이포그래피의 여러 어려움을 동반하는데, <a href="/kr/web-document/wd-002/">지난 웹</a>에 사용된 ‘AG 최정호 스크린’과 ‘어도비 캐슬론 프로’는 더욱이 예민한 시각적 보정을 필요로 했다. 인디자인과 같은 출판에 특화된 프로그램에서는 디테일한 마이크로 타이포그래피가 큰 문제로 다가오지 않지만<sup class="footnote-reference" id="fr-2-1"><a href="#fn-2">2</a></sup> 다양한 환경에 대응해야 하는 웹 환경에서는 다소 까다로운 조건으로 느껴졌다.
<br><br>
나는 이러한 경우의 수를 통제하기 위한 방법으로 <a href="/kr/method/mt-001/">모듈</a>의 아이디어를 떠올렸다.<sup class="footnote-reference" id="fr-3-1"><a href="#fn-3">3</a></sup> 고정폭 글꼴을 활용하면 ‘한글과 영문의 시각적 크기 차이에 따른 적절한 행간의 차이’와 ‘한글과 영문의 글꼴 설계구조 차이에 따른 기준선 차이’에 대한 문제를 쉽게 해결할 수 있을 것이라 생각했다. 이는 내가 경험적으로 고정폭 조판에서는 낱말사이가 넓어지거나 글줄사이가 좁아지더라도 가독성이 잘 유지된다고 느꼈기 때문이다. 더군다나 라틴 모노스페이스 글꼴의 전형적 특징인 높은 엑스하이트는 한글과의 질감 차이를 줄여줄 것으로 보였다. 나는 한글 글리프를 전각으로 기준 삼고, 라틴 알파벳을 비롯한 기타 글리프는 모두 반각으로 조정한 합성 글꼴을 만들기 시작했다.
<br><br>
하지만 글꼴을 완성하자 사소한 문제가 생겼다. <a href="/kr/works/project/pr-005/">이 글꼴</a>은 원래 제이에이치 웹 모노<em>JH Web Mono</em>라는 이름이 붙을 예정이었다. 그러나 이것은 사실 단일한<em>mono</em> 공간<em>space</em>을 사용한 글꼴이 아니다. 그렇다면 모노 대신에 어떤 이름을 붙여야 할까? 두 가지 고정폭? 반각 기준 글꼴? 순간 나는 그동안 ‘고정폭’, ‘모노스페이스’와 같은 단어를 모호하게 정의해 왔다는 사실을 깨달았다. ‘듀오스페이스‘라는 단어와의 만남은 이러한 질문에서부터 시작한다.
<br><br></p>
<p><strong>2. 듀오스페이스 글꼴이란</strong><br></p>
<p>위키피디아에 따르면 듀오스페이스 글꼴(Duospaced font, Duospace font)은 글자들이 특정한 너비의 두 정수배 중 하나를 차지하는 고정폭 글꼴을 의미한다. 이 용어는 전통적으로는 전각과 반각의 글자너비를 사용하는 글꼴을 의미하지만 반드시 그런 것만은 아니다. 두 글자너비의 비율이 2:1이 아니더라도 특정 비율을 가진 이중의 글자너비를 고정폭으로 사용하는 글꼴이라면 듀오스페이스 글꼴로 분류할 수 있다는 것이다. 모노스페이스는 하나의 너비를 사용하는 고정폭 글꼴을 의미하는 용어이므로 JH Web Mono는 JH Web Duo로 바꿔 부르는 것이 적절해 보였다. 나는 특정 두 글자너비를—그것도 2:1의 비율을 가지는—사용하는 글꼴을 부르는 명확한 명칭을 찾아낸 것이다.
<br><br>
흥미로운 점은 이 용어가 꽤나 낯설다는 사실이다. 나는 타이포그래피 수업에서 이 용어를 배운 적이 없다. 편집디자인 실무에서도 사용해본 적이 없으며 검색을 해봐도 관련 자료는 찾아보기 어렵다. 이는 한국타이포그라피학회의 <a rel="external" href="https://typography-dictionary.kr/">타이포그래피사전</a>에도 없는 용어다. 이쯤이면 이 용어가 보편적으로 사용되는 단어는 아니라는 것을 짐작할 수 있다. 나는 한글 타이포그래피 분야 혹은 동아시아 문화권에서 관련 용어가 어떻게 쓰이고 있는지 궁금해졌다.
<br><br></p>
<p><strong>3. CJK<sup class="footnote-reference" id="fr-4-1"><a href="#fn-4">4</a></sup> (동아시아)의 듀오스페이스 글꼴</strong><br></p>
<p>위키피디아는 듀오스페이스 글꼴을 CJK 타이포그래피 맥락에서 등장한 개념으로 서술한다. 전각을 기반으로 한 CJK 글꼴은 라틴 모노스페이스의 협소한 글자너비에 들어가기 어려웠고, 이러한 문제를 해결하기 위해 이중의 고정폭 개념이 등장했다는 것이다. 이 문서에 따르면 듀오스페이스는 1990년대 이후 사용되기 시작했다. 500년 정도의 타이포그래피 역사를 고려하면 이는 상당히 최근에 논의되기 시작한 개념이라 할 수 있다.
<br><br>
이어서 등장하는 내용은 흥미롭다. 듀오스페이스의 속성을 가진 CJK 글꼴들이 그냥 모노스페이스 혹은 고정폭으로 분류된다는 것이다. 한 가지의 고정폭만을 사용하는 CJK 글꼴은 실무 환경에서 일반적이라 보기 어렵고, CJK 문화권의 디자이너들 역시 이를 별도의 범주로 인식하거나 구별해 사용하는 경우는 드물다. 이는 결국 서구적 타이포그래피 분류 체계가 투영된 결과라 할 수 있다. 따라서 앞선 서술을 보강하자면, 듀오스페이스는 CJK 타이포그래피 맥락에서 스스로 형성된 개념이 아니라, 서구적 타이포그래피와의 관계 속에서 등장한 용어로 이해하는 편이 더 정확하다.
<br><br>
여기서 동일한 용어가 언어권에 따라 서로 다르게 해석될 수 있다는 점에 주목할 필요가 있다. 만약 단일한 글자너비의 체계를 필요로 하는 작업에서, 단순히 모노스페이스로 분류된 CJK 글꼴을 사용할 경우 프로젝트의 구조 자체가 흔들릴 수 있다. 문화권 간 용어 정의의 전제 자체가 다르기 때문이다. 이러한 불일치를 이해하기 위해 역사적 맥락을 먼저 살펴보자.
<br><br></p>
<p><strong>4. 글자너비의 역사적 맥락</strong><br></p>
<p>역사적으로 라틴 문자는 글자너비가 제각각인 비례폭 글꼴로 발전해왔다. 전통적인 라틴 문자의 조판은 기준선<em>baseline</em>에 따라 수평으로 정렬되며, 어센더와 디센더가 만들어내는 시각적 리듬이 더해진다. 때문에 글자너비가 달라도 유기적인 인상이 형성된다. 하지만 20세기에 접어들며 타자기나 컴퓨터 터미널 등의 특수한 환경에 맞는 고정폭 글꼴이 필요해졌고 모노스페이스 글꼴이 탄생했다. 모노스페이스는 전통적인 글꼴에 비해 유기적인 리듬은 제한적이지만, 이를 상쇄하는 여러 기능적 효과를 지닌다. 덕분에 모노스페이스는 현재까지도 다양한 상황에서 사용되는 대표적인 글꼴 양식으로 자리 잡았다.
<br><br>
모노스페이스 혹은 고정폭 라틴 글꼴은 기존의 비례폭 글꼴에 대비되는 속성을 온전히 지닌다. 이에 대한 주요한 이유 중 하나는 라틴 문자 환경의 쓰기 관습<sup class="footnote-reference" id="fr-5-1"><a href="#fn-5">5</a></sup>이 (CJK에 비해) 큰 변혁을 겪지 않았다는 점을 꼽을 수 있다. 서구에서 발명된 타자기와 컴퓨터 역시 기존의 서구적 쓰기 관습을 기반으로 설계되었다. 이러한 환경적 연속성 속에서 등장한 고정폭 글꼴은 기존의 비례폭 글꼴과의 명확한 형식적 대비 관계를 이룰 수 있었다.
<br><br>
이에 반해 CJK 문자는 본래 고정폭을 기반으로 설계되었다. 그러나 근대화 이후 서구의 조판 환경에 적응하는 과정에서 개념적 혼란이 생겨났다. 대표적인 예가 쓰기 방향에 관한 것이다. 전통적으로 CJK 문자는 세로쓰기가 일반적이었으나 현재는 세계적(혹은 서구적) 표준에 따라 가로쓰기가 널리 사용되고 있다. 이러한 쓰기 방향의 변화는 문자 배열의 구조뿐 아니라 시각적 균형 인식 자체를 바꿔놓기에 적절한 글자너비 공간에도 영향을 미친다.
<br><br>
예를 들어 가로쓰기용 한글은 한자와 가나에 비해 상대적으로 좁은 글자너비를 필요로 한다. 세로로 쓰인 한글은 홀자의 기둥흐름으로 수직의 시각적 기준선을 만들어낸다. 그러나 받침 영역이 불규칙적인 한글을 가로로 쓰면, 수평 방향의 시각적 흐름을 형성하기 어려워진다. 이러한 조건은 글자너비를 좁히는 경향성을 만들어낸다. 실제로 2010년대 이후의 한글꼴은 가로너비가 좁은 일종의 장체(Condensed)처럼 설계되는 사례가 증가하는 경향을 보인다. 이것은 정방형의 전각 단위로 설계된 이전의 글꼴들과 대비되는 특성이다.<sup class="footnote-reference" id="fr-6-1"><a href="#fn-6">6</a></sup> 이는 가로쓰기 환경에서 보기 편한 한글의 미감이 시대에 맞추어 변화하고 있음을 보여준다.
<br><br>
더군다나 CJK 글꼴은 CJK 문자만으로 이루어지지 않는다. 상업적으로 판매되는 대다수의 가로쓰기용 CJK 글꼴은 로마자를 포함하며, 설령 로마자를 사용하지 않더라도 문장부호와 숫자는 라틴 문자의 쓰기 관습을 바탕으로 한다. 생성원리부터 다른 외국의 글자와 한글꼴 사이의 형태적 균형을 잡는 일은 분명 쉽지 않은 문제다. 이러한 상황에서 CJK 글꼴의 글자너비를 엄격한 분류 체계로 구분하는 일은 제한적일 수밖에 없다.
<br><br>
이처럼 다양한 쓰기 관습이 섞인 현대의 CJK 문자는 더 이상 완전한 고정폭도, 완전한 비례폭도 아닐 수밖에 없다. 개념적 혼동을 줄이기 위해서는 먼저 용어의 정의에 대한 논의가 필요하다.
<br><br></p>
<p><strong>5. 고정폭, 모노스페이스, 듀오스페이스</strong><br></p>
<p>나는 다음의 세 가지 용어의 정의를 이렇게 분류할 것을 제안한다.
<br><br>
<em><strong>고정폭 CJK 글꼴:</strong></em><br>
한글, 한자, 가나를 뜻하는 주요 문자 글리프가 하나의 글자너비로 설계된 CJK 글꼴. 이때 숫자, 구두점, 공백 등 부수적 글리프가 비례폭으로 설계되었더라도 이를 고정폭 글꼴로 분류한다. 이는 이미 기존의 대다수 CJK 글꼴을 ‘고정폭‘으로 분류하고 있는 관습에 근거한다. 이 정의는 ‘모노스페이스’와 ‘듀오스페이스’를 포괄하는 상위 개념으로 작동한다. 나는 보다 엄격한 뜻으로 이루어진 ‘모노스페이스’라는 단어를 한정적으로 사용하기 위해 ‘고정폭’이라는 용어에 관습적 분류의 역할을 부여할 것을 제안한다.
<br><br>
<em><strong>모노스페이스 CJK 글꼴:</strong></em><br>
모든 글리프가 단일한 글자너비로 설계된 CJK 글꼴. 이때 글자너비는 반드시 정방형일 필요는 없다. 이는 기존의 관습보다 엄격한 기준이 된다. 한글, 한자, 가나뿐 아니라 숫자, 구두점, 공백을 포함한 글리프가 동일한 글자너비로 설계된 경우에만 ‘모노스페이스’라고 분류한다. 라틴 문자 환경에서의 ‘모노스페이스’ 기능을 엄밀히 구현하고자 할 경우, 이 정의를 따르는 글꼴을 선택해야 한다.
<br><br>
<em><strong>듀오스페이스 CJK 글꼴:</strong></em><br>
모든 글리프가 두 가지의 글자너비로 설계된 CJK 글꼴. 이는 일반적으로 정의되는 ‘듀오스페이스’ 개념과 같다. 기존의 개념적 혼란은 ‘듀오스페이스’에 해당하는 글꼴이 관습적인 이유로 ‘모노스페이스’로 분류되면서 발생한 측면이 크다. 따라서 ‘모노스페이스’와 ‘듀오스페이스’를 엄격히 구분한다면 해당 혼동 역시 상당 부분 해소될 것이다.
<br><br></p>
<p><strong>6. 듀오스페이스에 대한 생각</strong><br></p>
<p>CJK 글꼴을 엄밀한 의미의 ‘모노스페이스’로 설계하는 일은 가독성 측면에서 상당히 실험적인 시도다. 나는 듀오스페이스 CJK 글꼴뿐 아니라 모노스페이스 CJK 글꼴의 가능성에도 강한 흥미가 있지만, 그러한 탐구의 의미를 유지하기 위해서는 개념적 혼용을 피하는 일이 중요해진다.
<br><br>
현재의 나로서는, 실용적인 가독성을 확보하는 고정폭 CJK 글꼴로서는 듀오스페이스가 가장 현실적인 선택지로 보인다. 무엇보다도 전각 단위의 낱말사이 간격에서는 여전히 시각적 저항감이 강하게 느껴진다. 보다 미세한 타이포그래피 조정에 능숙해진다면, 이러한 제약 역시 새로운 조형적 가능성으로 전환시킬 수 있을 것이다. 글자너비에 대한 이 고민들이 앞으로의 작업에서 새로운 아이디어로 이어지기를 기대한다.</p>
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn-1">
<p>웹 리뉴얼(2026)에 대한 정보는 <a href="/kr/about/about/">이 웹에 대하여</a>를 참고 <a href="#fr-1-1">↩</a></p>
</li>
<li id="fn-2">
<p>문제가 있더라도 비교적 쉽게 조정이 가능하다. 어찌됐건 출판물의 판형은 움직이지 않으니까. <a href="#fr-2-1">↩</a></p>
</li>
<li id="fn-3">
<p>웹을 공부하기 시작한 지 얼마 되지 않은 터라, 아직 다른 대안은 잘 떠오르지 않는다. ’디지털 환경에서 효과적인 타이포그래피‘에 대해 앞으로 계속 고민해볼 예정이다. <a href="#fr-3-1">↩</a></p>
</li>
<li id="fn-4">
<p>CJK는 China, Japan, Korea의 문자 환경을 묶어 부르는 타이포그래피 용어다. 서구권에서는 이를 동아시아 타이포그래피(East Asian Typography)라고 부르기도 하는데, 이는 너무 넓은 지리적 범위를 포함하므로 ‘동북아시아’ 내지는 ‘한자 문화권’으로 번역하는 편이 적절할 것이다. 하지만 이것도 정확하지는 않다. CJK는 중국, 일본, 한국의 문자환경을 의미하는 하나의 고유명사에 가깝기 때문이다. 따라서 이 문서에서는 직관적인 의미는 다소 떨어지지만 보다 정확한 용어인 CJK를 번역하지 않고 그대로 쓰기로 한다. <a href="#fr-4-1">↩</a></p>
</li>
<li id="fn-5">
<p>이 문서에서 ‘쓰기 관습’은 ‘글을 쓰는 총체적인 관습과 양식’을 통틀어 의미하는 단어로 사용된다. ‘쓰기 체계’라는 단어를 사용하려고 했지만 이는 타이포그래피 용어로 ‘Writing System’에 대응될 수 있어 피하고자 했다. ‘Writing System’은 알파벳이나 가나 등 언어 단위의 문자 체계를 의미한다. <a href="#fr-5-1">↩</a></p>
</li>
<li id="fn-6">
<p>노토 산스, 산돌 고딕 등의 글자 모두 가로너비가 세로의 높이보다 좁다. 때문에 노토 산스를 기반으로 한 <a href="/kr/works/project/pr-005/">제이에이치 웹 듀오</a> 또한 전각 단위를 정사각형이 아닌 직사각형으로 기준 삼고 있다. <a href="#fr-6-1">↩</a></p>
</li>
</ol>
</section>


  </div>

</article>

<div id="image-viewer" aria-hidden="true">
  <button class="viewer-close" aria-label="Close">×</button>
  <button class="viewer-prev" aria-label="Previous">←</button>
  <img class="viewer-image" alt="" />
  <button class="viewer-next" aria-label="Next">→</button>
</div>


<script>
  (function () {
  
    function isVisible(el) {
      return !!(el && el.offsetParent !== null);
    }
  
    function isInViewport(el) {
      if (!el) return false;
      const r = el.getBoundingClientRect();
      return r.bottom > 0 && r.top < window.innerHeight;
    }
  
    function scrollToRef(el, block) {
      if (!el) return;
      el.scrollIntoView({
        behavior: "smooth",
        block: block
      });
    }
  
    function scrollDocumentToRevealMeta() {
      window.scrollTo({
        top: document.documentElement.scrollHeight,
        behavior: "smooth"
      });
    }
  
    function setActiveFootnote(id) {
      history.pushState(null, "", "#" + id);
  
      document.querySelectorAll(".meta-note").forEach(el => {
        el.classList.toggle("is-active", el.dataset.fnid === id);
      });
  
      document.querySelectorAll(".footnotes-list li[id]").forEach(el => {
        el.classList.toggle("is-active", el.id === id);
      });
    }
  
    const mqDesktop = window.matchMedia("(min-width: 600px)");
  
    document.addEventListener("click", function (e) {
  
      const meta = e.target.closest(".meta-note[data-fnid]");
      if (meta) {
        if (e.target.closest("a")) return;
  
        const id = meta.dataset.fnid;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const def = e.target.closest(".footnotes-list li[id]");
      if (def) {
        if (e.target.closest("a")) return;
  
        const id = def.id;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const refLink = e.target.closest(".footnote-reference a[href^='#']");
      if (!refLink) return;
  
      e.preventDefault();
  
      const id = refLink.getAttribute("href").slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
  
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
    document.addEventListener("DOMContentLoaded", function () {
      if (!location.hash.startsWith("#")) return;
  
      const id = location.hash.slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
  })();
  </script>  
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const PUNCTS = `"'\u2018\u201C([{‹«〈《「『`;
    
        const targets = document.querySelectorAll(
  '.page-meta .meta-title, \
   .page-meta .meta-line, \
   .page-body .page-content p, \
   .page-body .page-content li'
);

    
      targets.forEach(el => {
        const text = (el.textContent || '').trimStart();
        if (!text) return;
    
        const firstChar = text[0];
        if (!PUNCTS.includes(firstChar)) return;
    
        el.classList.add('hang-punct');
      });
    });
    </script>
    
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const superscriptMap = {
          "0": "⁰",
          "1": "¹",
          "2": "²",
          "3": "³",
          "4": "⁴",
          "5": "⁵",
          "6": "⁶",
          "7": "⁷",
          "8": "⁸",
          "9": "⁹"
        };
      
        document
          .querySelectorAll("sup.footnote-reference a")
          .forEach(el => {
            const text = el.textContent.trim();
      
            if (!/^\d+$/.test(text)) return;
      
            const superscript = [...text]
              .map(d => superscriptMap[d] || d)
              .join("");
      
            el.textContent = superscript;
            el.setAttribute("aria-label", `Footnote ${text}`);
          });
      });
      </script>
      
      <script>
        (function () {
          const root = document.querySelector(".page-body.page-content");
          if (!root) return;

          root.querySelectorAll("blockquote ol > li").forEach(li => {
            if (li.querySelector(":scope > .li-body")) return;

            const body = document.createElement("span");
            body.className = "li-body";

            const nodes = Array.from(li.childNodes);

            nodes.forEach(node => {
              if (
                node.nodeType === Node.ELEMENT_NODE ||
                (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "")
              ) {
                body.appendChild(node);
              }
            });

            li.appendChild(body);
          });
        })();
        </script>


        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const root = document.querySelector(".page-body.page-content");
            if (!root) return;
          
            root.querySelectorAll("p > strong").forEach(strong => {
              const parent = strong.parentElement;
              if (parent && parent.classList.contains("centered-strong")) return;
          
              const wrapper = document.createElement("span");
              wrapper.className = "centered-strong";
          
              parent.replaceChild(wrapper, strong);
              wrapper.appendChild(strong);
            });
          });
          </script>
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const isMobile = window.matchMedia("(max-width: 600px)").matches;
    
      const images = Array.from(
        document.querySelectorAll(".page-body.page-content figure img")
      );
      if (!images.length) return;
    
      const viewer = document.getElementById("image-viewer");
      const viewerImg = viewer.querySelector(".viewer-image");
      const btnClose = viewer.querySelector(".viewer-close");
      const btnPrev = viewer.querySelector(".viewer-prev");
      const btnNext = viewer.querySelector(".viewer-next");
    
      let currentIndex = 0;
      let scrollY = 0;
    
      function lockScroll() {
        scrollY = window.scrollY;
        document.body.style.position = "fixed";
        document.body.style.top = `-${scrollY}px`;
        document.body.style.left = "0";
        document.body.style.right = "0";
        document.body.style.width = "100%";
      }
    
      function unlockScroll() {
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.left = "";
        document.body.style.right = "";
        document.body.style.width = "";
        window.scrollTo(0, scrollY);
      }
    
      function openViewer(index) {
        currentIndex = index;
        viewerImg.src = images[currentIndex].src;
        viewer.classList.add("is-open");
        viewer.setAttribute("aria-hidden", "false");
    
        if (isMobile) lockScroll();
      }
    
      function closeViewer() {
        viewer.classList.remove("is-open");
        viewer.setAttribute("aria-hidden", "true");
    
        if (isMobile) unlockScroll();
      }
    
      function prev() {
        if (currentIndex > 0) openViewer(currentIndex - 1);
      }
    
      function next() {
        if (currentIndex < images.length - 1) openViewer(currentIndex + 1);
      }
    
      images.forEach((img, i) => {
        img.style.cursor = "zoom-in";
        img.addEventListener("click", () => openViewer(i));
      });
    

      if (!isMobile) {
        btnClose.addEventListener("click", closeViewer);
        btnPrev.addEventListener("click", prev);
        btnNext.addEventListener("click", next);
    
        viewerImg.addEventListener("click", closeViewer);
        viewer.addEventListener("click", e => {
          if (e.target === viewer) closeViewer();
        });
      }
    
      if (isMobile) {
        viewer.addEventListener("click", closeViewer);
    
        let startX = 0;
        let startY = 0;
    
        viewer.addEventListener(
          "touchstart",
          e => {
            const t = e.touches[0];
            startX = t.clientX;
            startY = t.clientY;
          },
          { passive: true }
        );
    
        viewer.addEventListener("touchend", e => {
          const t = e.changedTouches[0];
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
    
          if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
            dx > 0 ? prev() : next();
          }
        });
      }
    
      document.addEventListener("keydown", e => {
        if (!viewer.classList.contains("is-open")) return;
    
        if (e.key === "Escape") closeViewer();
        if (e.key === "ArrowLeft") prev();
        if (e.key === "ArrowRight") next();
      });
    });
    </script>
    

    <script>
      (function () {
        if (!window.matchMedia("(min-width: 601px)").matches) return;
    
        const preview = document.createElement("div");
        preview.id = "link-preview";
        document.body.appendChild(preview);
    
        let aborter = null;
    
        function isHomeLink(a) {
          if (!a || !a.href) return false;
          try {
            const url = new URL(a.href);
            if (url.origin !== location.origin) return false;
            return url.pathname === "/" || url.pathname === "/kr/";
          } catch {
            return false;
          }
        }
    
        function isInternalLink(a) {
          if (!a || !a.href) return false;
          try {
            return new URL(a.href).origin === location.origin;
          } catch {
            return false;
          }
        }
    
        function extractPreviewText(html) {
          const doc = new DOMParser().parseFromString(html, "text/html");
          const body = doc.querySelector(".page-body");
          if (!body) return "";
    
          body.querySelectorAll(
            "figure, img, pre, code, table, script, style, .footnotes, .footnotes-list, aside"
          ).forEach(el => el.remove());
    
          body.querySelectorAll("sup").forEach(el => el.remove());
    
          const candidates = Array.from(body.querySelectorAll("p, li"))
            .map(el => el.textContent.replace(/\s+/g, " ").trim())
            .filter(text => text.length > 0);
    
          return candidates[0] || "";
        }
    
        function positionPreview(e) {
          const offset = 14;
          const maxX = window.innerWidth - preview.offsetWidth - 8;
          const maxY = window.innerHeight - preview.offsetHeight - 8;
    
          preview.style.left = Math.min(e.clientX + offset, maxX) + "px";
          preview.style.top = Math.min(e.clientY + offset, maxY) + "px";
        }
    
        document.addEventListener("mouseover", async (e) => {
          const a = e.target.closest("a[href]");
          if (!a) return;
          if (a.closest("header")) return;
          if (a.closest("sup")) return;
    
          aborter?.abort();
          aborter = new AbortController();
    
          if (isHomeLink(a) && a.closest(".page-two-col")) {
            preview.textContent = sessionStorage.getItem("jh_site_title") || "J—H";
            preview.classList.add("is-visible");
            positionPreview(e);
            return;
          }
    
          if (!isInternalLink(a) || !a.closest(".page-two-col")) return;
    
          try {
            const res = await fetch(a.href, { signal: aborter.signal });
            const html = await res.text();
            const text = extractPreviewText(html);
            if (!text) return;
    
            preview.textContent = text;
            preview.classList.add("is-visible");
            positionPreview(e);
          } catch {}
        });
    
        document.addEventListener("mousemove", (e) => {
          if (!preview.classList.contains("is-visible")) return;
          positionPreview(e);
        });
    
        document.addEventListener("mouseout", (e) => {
          const a = e.target.closest("a[href]");
          if (!a) return;

          if (a.contains(e.relatedTarget)) return;

          preview.classList.remove("is-visible");
          aborter?.abort();
        });

      })();
    </script>
    




    </main>

<footer class="footer" role="contentinfo">
  <p class="footer__text">
    © 2026 <span id="footer-site-title"></span><span class="footer-sep"></span>
    
      <span class="footer-msg">이 웹사이트는 <span id="footer-variant">(당분간은)</span> 제작중이다.</span>
    
  </p>

</footer>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("menu-toggle");
    const menu = document.getElementById("global-menu");
    if (!btn || !menu) return;

    const openMenu = () => {
      menu.hidden = false;
      btn.setAttribute("aria-expanded", "true");
      document.body.classList.add("menu-open");
    };

    const closeMenu = () => {
      menu.hidden = true;
      btn.setAttribute("aria-expanded", "false");
      document.body.classList.remove("menu-open");
    };

    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const expanded = btn.getAttribute("aria-expanded") === "true";
      expanded ? closeMenu() : openMenu();
    });

    document.addEventListener("click", (e) => {
      if (!menu.contains(e.target) && !btn.contains(e.target)) {
        closeMenu();
      }
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeMenu();
    });
  });
</script>


    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const currentHost = window.location.hostname;
        document
          .querySelectorAll('a[href^="http"]')
          .forEach(link => {
            const url = new URL(link.href);
            if (url.hostname !== currentHost) {
              link.setAttribute("target", "_blank");
              link.setAttribute("rel", "noopener noreferrer");
            }
          });
      });
    </script>


<script>
  const SITE_TITLES = [
    "J—H",
    "j—h",
    "Jaydashaitch",
    "제이대시에이치",
    "제이(대시)에이치",
    "JAY(DASH)AITCH",
    "JH ARCHIVE",
    "JAEHYEON LEE",
    "JAE—HYEON",
    "jay—aitch",
    "JAE(DASH)HYEON"
  ];
  
  function pickRandom(list) {
    return list[Math.floor(Math.random() * list.length)];
  }
  
  function pickRandomDifferent(list, current) {
    const pool = list.filter(item => item !== current);
    return pool.length
      ? pool[Math.floor(Math.random() * pool.length)]
      : current;
  }
  
  (function () {
    const titleEl = document.getElementById("site-title");
    const footerEl = document.getElementById("footer-site-title");
    if (!titleEl || !footerEl) return;
  
    const KEY = "jh_site_title";
  
    const renderTitle = (el, text) => {
      el.innerHTML = "";
      [...text].forEach(char => {
        const span = document.createElement("span");
        span.textContent = char;
        el.appendChild(span);
      });
    };
  
    if (!sessionStorage.getItem(KEY)) {
      sessionStorage.setItem(KEY, pickRandom(SITE_TITLES));
    }
  
    const initial = sessionStorage.getItem(KEY);
    renderTitle(titleEl, initial);
    footerEl.textContent = initial;
  
    titleEl.addEventListener("click", (e) => {
      e.preventDefault();
  
      const IS_HOME =
        window.location.pathname === "/" ||
        window.location.pathname === "/kr/";
  
      if (!IS_HOME) {
        window.location.href = titleEl.href;
        return;
      }
  
      const current = sessionStorage.getItem(KEY);
      const next = pickRandomDifferent(SITE_TITLES, current);
      sessionStorage.setItem(KEY, next);
  
      const layer = document.createElement("div");
      layer.className = "falling-layer";
      document.body.appendChild(layer);
  
      [...titleEl.children].forEach(originalSpan => {
        const rect = originalSpan.getBoundingClientRect();
  
        const span = document.createElement("span");
        span.className = "falling-char";
        span.textContent = originalSpan.textContent;
  
        span.style.left = `${rect.left}px`;
        span.style.top = `${rect.top}px`;
        span.style.animationDelay = `${Math.random() * 0.15}s`;
        span.style.animationDuration = `${1.2 + Math.random() * 1.6}s`;
  
        layer.appendChild(span);
      });
  
      titleEl.classList.add("is-switching");
  
      renderTitle(titleEl, next);
      footerEl.textContent = next;
  
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          titleEl.classList.remove("is-switching");
        });
      });
  
      setTimeout(() => {
        layer.remove();
      }, 2000);
    });
  })();
</script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const target = document.getElementById("footer-variant");
        if (!target) return;
      
        const lang = document.documentElement.lang;
      
        const variants = lang === "ko"
          ? [
              "(한동안은)",
              "(당분간은)",
              "(얼마간은)",
              "(현재로서는)",
              "(일단은)",
              "(우선은)",
              "(잠시나마)",
              "(당장까지는)",
              "(지금으로서는)",
              "(일정 기간동안은)",
              "(잠정적으로)",
              "(잠시 동안은)",
              "(지금은 계속)"
            ]
          : [
              "(for a while)",
              "(for now)",
              "(for the time being)",
              "(temporarily)",
              "(for the moment)",
              "(in the meantime)",
              "(for some time)",
              "(briefly)",
              "(until further notice)",
              "(as of now)",
              "(for a certain period)",
              "(still)",
              "(for a short while)"
            ];
      
        let current = target.textContent;
      
        const pickNext = () => {
          let next;
          do {
            next = variants[Math.floor(Math.random() * variants.length)];
          } while (next === current);
      
          current = next;
          target.textContent = next;
        };
      
        setInterval(pickNext, 1000);
      });
      </script>
  
  <script>
    (function () {
    
      const tooltip = document.createElement("div");
      tooltip.id = "menu-tooltip";
      document.body.appendChild(tooltip);
    
      const canHover = window.matchMedia("(hover: hover)").matches;
    
      function position(x, y) {
        const offset = 6;
    
        tooltip.style.left = x + offset + "px";
        tooltip.style.top = y + "px";
    
        tooltip.style.height = "";
        tooltip.style.lineHeight = "";
    
        tooltip.style.bottom = "";
        tooltip.style.transform = "";
      }
    
      function show(message, x, y) {
        tooltip.textContent = message;
        tooltip.classList.add("is-visible");
    
        position(x, y);
    
        if (!canHover) {
          clearTimeout(tooltip._timer);
    
          tooltip._timer = setTimeout(() => {
            tooltip.classList.remove("is-visible");
          }, 900);
        }
      }
    
      function getTextRect(el) {
        const range = document.createRange();
        range.selectNodeContents(el);
        return range.getBoundingClientRect();
      }
    
      if (canHover) {
    
        document.addEventListener("mouseover", (e) => {
    
          const disabled = e.target.closest(".menu-item--disabled");
          if (!disabled) return;
    
          const lang = document.documentElement.lang;
    
          show(
            lang === "ko" ? "준비중..." : "Coming soon...",
            e.clientX,
            e.clientY
          );
    
        });
    
        document.addEventListener("mousemove", (e) => {
          if (!tooltip.classList.contains("is-visible")) return;
    
          position(e.clientX, e.clientY);
        });
    
        document.addEventListener("mouseout", (e) => {
          if (!e.target.closest(".menu-item--disabled")) return;
    
          tooltip.classList.remove("is-visible");
        });
    
      } else {
    
        document.addEventListener("touchstart", (e) => {
    
          const disabled = e.target.closest(".menu-item--disabled");
          if (!disabled) return;
    
          const lang = document.documentElement.lang;
          const rect = getTextRect(disabled);
    
          show(
            lang === "ko" ? "준비중..." : "Coming soon...",
            rect.right,
            rect.top
          );
    
        });
    
      }
    
    })();
    </script>


  </body>
</html>
