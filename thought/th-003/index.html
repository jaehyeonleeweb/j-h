<!DOCTYPE html>


  


<script>
  console.log("current_path:", "/thought/th-003/");
</script>

<script>
  console.log("lang:", "en");
  console.log("section.lang:", "(no section)");
  console.log("page.lang:", "en");
</script>


<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>About Duospaced Font, J-H</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">

    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <header class="header" role="banner">
      <button
        class="menu-toggle"
        id="menu-toggle"
        aria-expanded="false"
        aria-controls="global-menu"
      >
       
          MENU
       
      </button>

      <a href="/" class="site-title" id="site-title"></a>

      <span class="lang-toggle" data-lang="en">
        
          <a
            href="/kr&#x2F;thought&#x2F;th-003&#x2F;"
            class="ko"
          >한</a>
          <span class="sep"> / </span>
          <span class="en">EN</span>
        
      </span>
      
    </header>

    <nav
      id="global-menu"
      class="global-menu"
      aria-label="primary"
      hidden
    >
      
        <a href="/allarchive/">All Archive</a>
        
        <a href="/about/">About</a>
        <a href="/contact/">Contact</a>
        <span class="menu-item--disabled" aria-disabled="true">Shop</span>
      
    </nav>

    <main id="content">
      

<article class="page-two-col" role="article">

  <aside class="page-meta" role="complementary">

    <div class="meta-block meta-title">
      <strong>About Duospaced Font</strong>
    </div>

    <div class="meta-block meta-data">

      
        <div class="meta-line">
          
            Document No. → [20]
          
        </div>
      
    
      
        <div class="meta-line">
          
            Category → [Thought]
          
        </div>
      
    
      
    
    
    
    
    
    
    
    
    
      <div class="meta-line">
        
          Date →
        
    
        
        
          [Feb 2026]
        
      </div>
    

      
  
  
    
    </div>
    

    
    

    
    <div class="meta-block meta-notes">
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-1"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">1</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            For information on the web renewal (2026), see <a href="/about/about/">About</a>.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-2"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">2</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            Even if there are issues, adjustments are relatively easy. After all, the format of a published work doesn't change.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-3"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">3</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            Since I've only recently started studying web design, other alternatives don't readily come to mind yet. I plan to continue exploring ‘effective typography in digital environments’ going forward.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-4"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">4</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            CJK is a typography term grouping the character environments of China, Japan, and Korea. In Western contexts, it is sometimes called East Asian Typography. However, since this encompasses too broad a geographical scope, translating it as <em>Northeast Asia</em> or <em>the Sinitic cultural sphere</em> would be more appropriate. But even this isn't entirely accurate. This is because CJK is closer to being a proper noun denoting the writing systems of China, Japan, and Korea. Therefore, this document will retain the term CJK without translation, despite its less intuitive meaning, as it is the more accurate term.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-5"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">5</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            In this document, <em>writing conventions</em> is used as a broad term encompassing “the overall customs and styles of writing”. The term <em>writing system</em> was considered but avoided as it corresponds to the typography term <em>Writing System</em>. <em>Writing System</em> refers to the character system at the language level, such as alphabets or kana.
          </span>
        </div>
      
        <div
          class="meta-line meta-note"
          data-fnid="fn-6"
          role="link"
          tabindex="0"
        >
          <span class="footnote-num">6</span>
          <span class="footnote-arrow"> → </span>
          <span class="footnote-text">
            Fonts like Noto Sans and Sandoll Gothic all have a horizontal width narrower than their vertical height. Consequently, the <a href="/works/project/pr-005/">JH Web Duo</a> based on Noto Sans also uses a rectangular unit, not a square, as its full-width character standard.
          </span>
        </div>
      
    </div>
    
    

  </aside>

  <div class="page-body page-content">

    <p><strong>1. Regarding the Term Duospaced Font</strong><br></p>
<p>While renewing <a href="/web-document/wd-002/">the previous web</a>,<sup class="footnote-reference" id="fr-1-1"><a href="#fn-1">1</a></sup> I encountered the problematic term <em>Duospace</em>. More precisely, it was during the production of the <a href="/works/project/pr-005/">JH Web Duo</a>. The mixed typesetting of <a href="/web-document/wd-002/">the previous web</a> was a troublesome task in many ways. I am creating all documents for <a rel="external" href="https://j-h-a-r-c-h-i-v-e.com/">this web</a> in both Korean and English versions. This constraint inevitably brings numerous difficulties in multilingual typography. The fonts used on <a href="/web-document/wd-002/">The Previous Web</a>, <em>AG Choijeongho Screen</em> and <em>Adobe Caslon Pro</em>, required even more sensitive visual adjustments. While detailed microtypography isn't a major issue in publishing environments like InDesign,<sup class="footnote-reference" id="fr-2-1"><a href="#fn-2">2</a></sup> it felt like quite a demanding condition for the web, which must adapt to diverse environments.
<br><br>
To control these variables, I conceived the idea of <a href="/method/mt-001/">modules</a>.<sup class="footnote-reference" id="fr-3-1"><a href="#fn-3">3</a></sup> I believed utilizing a monospace font would relatively easily resolve issues like line spacing problems caused by the visual size difference between Hangul and Latin characters, and baseline issues stemming from differences in font design structures. This stemmed from my empirical observation that monospace typesetting maintained good readability. The high x-height, a typical characteristic of Latin monospace fonts, also seemed likely to reduce the textural difference with Hangul. I began creating a composite font where Hangul glyphs were set to full-width standards, while Latin alphabets and other glyphs were adjusted to half-width.
<br><br>
However, upon completing the font, a minor issue arose. <a href="/works/project/pr-005/">This font</a> was originally intended to be named JH Web Mono. But it wasn't actually a font using a single space. So what name should replace <em>mono</em>? Two fixed-widths? A half-width-based font? I realized I had been vaguely defining terms like <em>fixed-width</em> and <em>monospace</em> all along. My encounter with the term <em>duospace</em> began with these questions.
<br><br>
<strong>2. What is a Duospaced Font?</strong><br></p>
<p>According to Wikipedia, a duospaced font is a fixed-width font in which characters occupy either of two integer multiples of a specified fixed horizontal space. Traditionally, this meant characters occupying either a single or double character width, though the ratio need not be strictly 2:1. More broadly, the term may also apply to fonts that employ fixed character widths based on another simple proportional relationship. I decided to replace <em>Mono</em> with <em>Duo</em> after arriving at this definition.
<br><br>
What is particularly interesting is how unfamiliar this term feels. I never encountered it in typography classes, nor have I ever used it in editorial design practice. Even when searching online, relevant references are difficult to find, and the term is not even listed in the <a rel="external" href="https://typography-dictionary.kr/">Typography Dictionary (Korean Society of Typography)</a>. This suggests that the term is not commonly used. I became curious about how this term is used within Korean typographic discourse, or more broadly, within the East Asian typographic context.
<br><br></p>
<p><strong>3. Duospace Fonts in CJK<sup class="footnote-reference" id="fr-4-1"><a href="#fn-4">4</a></sup> (East Asia)</strong><br></p>
<p>Wikipedia describes duospace fonts as a concept emerging within the context of CJK typography. CJK fonts based on full-width characters struggled to fit within the narrow character widths of Latin monospace fonts, leading to the development of the dual fixed-width concept to address this issue. According to this document, DuoSpace began to be used after the 1990s. Considering typography’s roughly 500-year history, this is a concept that has only recently entered discussion.
<br><br>
The subsequent content is intriguing. It states that CJK fonts possessing duospace attributes are simply classified as monospace or fixed-width. CJK fonts using only a single fixed width are rarely seen as common in practical environments, and designers within CJK cultural spheres also seldom recognize or distinguish them as a separate category. This ultimately reflects the projection of Western typographic classification systems. Therefore, to reinforce the earlier point, it is more accurate to understand duospace not as a concept formed independently within the CJK typographic context, but rather as a term that emerged within the relationship with Western typography.
<br><br>
Here, it is important to note that the same term can be interpreted differently across language groups. If a CJK font classified as monospace is used in a project requiring a uniform character width system, the project’s structure itself could be undermined. This is because the very premise of term definitions differs between cultural spheres. To understand this discrepancy, let us first examine the historical context.
<br><br></p>
<p><strong>4. Historical Context of Character Width</strong><br></p>
<p>Historically, Latin characters evolved into proportional-width fonts, where each character has its own width. Traditional Latin typesetting aligns characters horizontally along a baseline, enhanced by the visual rhythm created by ascenders and descenders. This creates an organic impression even with varying character widths. However, entering the 20th century, fixed-width fonts became necessary for specialized environments such as typewriters and computer terminals, leading to the birth of monospace fonts. While monospace fonts offer limited organic rhythm compared to traditional fonts, they possess several functional advantages that compensate for this. Consequently, monospace fonts have established themselves as a representative font style used in diverse situations to this day.
<br><br>
Monospace or fixed-width Latin fonts fully embody attributes contrasting with existing proportional-width fonts. A key reason for this is that writing conventions<sup class="footnote-reference" id="fr-5-1"><a href="#fn-5">5</a></sup> in the Latin character environment underwent far less transformation compared to CJK. Typewriters and computers invented in the West were also designed based on existing Western writing conventions. Fixed-width fonts, emerging within this environmental continuity, could establish a clear formal contrast with existing proportional-width fonts.
<br><br>
In contrast, CJK characters were originally designed based on fixed width. However, conceptual confusion arose during the process of adapting to Western typesetting environments after modernization. A prime example is the shift in writing direction. Traditionally, vertical writing was common for CJK characters, but horizontal writing is now widely used according to global standards.<sup class="footnote-reference" id="fr-6-1"><a href="#fn-6">6</a></sup> This change in writing direction alters not only the structure of character arrangement but also the very perception of visual balance, affecting the appropriate character width spacing.
<br><br>
For instance, Hangeul designed for horizontal writing requires relatively narrower character widths compared to Hanja and kana. Vertically written Hangeul creates a vertical visual baseline through the flow of the stem of the ‘hol’ character. However, arranging Hangeul horizontally, with its irregular consonant areas, makes it difficult to form a horizontal visual flow. These conditions create a tendency to narrow character widths. Indeed, since the 2010s, Korean typefaces have increasingly featured designs closer to narrow-width Jangche styles. This contrasts with earlier fonts designed around square full-width units. This shift demonstrates how the aesthetic of visually comfortable Korean in horizontal writing is evolving with the times.
<br><br>
Moreover, CJK fonts are not composed solely of CJK characters. The vast majority of commercially available CJK fonts for horizontal writing include Roman characters. Even when Roman characters are not used, punctuation marks and numerals are based on Latin writing conventions. Maintaining morphological balance between character systems with fundamentally different generation principles is inherently complex. In this context, strictly categorizing CJK font character widths into rigid classifications is inherently limited.
<br><br>
Thus, modern CJK characters, blending diverse writing conventions, can no longer be purely fixed-width or purely proportional-width. To reduce conceptual confusion, a discussion on defining terminology is first necessary.
<br><br></p>
<p><strong>5. Fixed-width, Monospace, Duospace</strong><br></p>
<p>I propose classifying the definitions of the following three terms as follows.
<br><br>
<em><strong>Fixed-width CJK font:</strong></em><br>
A CJK font in which the primary character glyphs—representing Hangeul, Hanja, and Kana—are designed with a single character width. Even if supplementary glyphs such as numerals, punctuation, and spaces are designed with proportional widths, the font is still classified as fixed-width. This definition is based on the prevailing convention that classifies the majority of CJK fonts as fixed-width. It functions as a superordinate concept encompassing both monospace and duospace. I propose assigning the term <em>fixed-width</em> the role of conventional classification, thereby allowing the term <em>monospace</em>, which carries a stricter meaning, to be used more restrictively.
<br><br>
<em><strong>Monospace CJK font:</strong></em><br>
A CJK font in which all glyphs are designed with a single character width. This width need not be square. This definition represents a stricter criterion than existing conventions. Only fonts in which all glyphs share identical character widths—including Hangeul, Hanja, Kana, as well as numerals, punctuation, and spaces—are classified as monospace. When strictly implementing monospace functionality within a Latin typographic environment, fonts adhering to this definition must be selected.
<br><br>
<em><strong>Duospace CJK font:</strong></em><br>
A CJK font in which all glyphs are designed with two character widths. This aligns with the generally accepted concept of duospace. Much of the existing conceptual confusion stems from fonts that would more accurately be described as duospaced being conventionally classified as monospace. Therefore, a strict distinction between monospace and duospace would substantially reduce such ambiguity.
<br><br></p>
<p><strong>6. Thoughts on Duospace</strong><br></p>
<p>Designing CJK fonts as monospace in the strict sense represents a highly experimental endeavor in terms of readability. While I maintain a strong interest in exploring not only duospace CJK fonts but also the potential of monospace CJK fonts, avoiding conceptual conflation becomes essential for preserving the meaning of such exploration.
<br><br>
From my present perspective, duospace appears to be the most realistic choice for a fixed-width CJK font capable of ensuring practical readability. Above all, I continue to perceive a strong sense of visual resistance in word spacing based on full-width units. With greater proficiency in finer typographic adjustments, I believe such constraints may also be transformed into new typographic possibilities. I hope these considerations regarding character width will lead to new ideas in future work.</p>
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn-1">
<p>For information on the web renewal (2026), see <a href="/about/about/">About</a>. <a href="#fr-1-1">↩</a></p>
</li>
<li id="fn-2">
<p>Even if there are issues, adjustments are relatively easy. After all, the format of a published work doesn't change. <a href="#fr-2-1">↩</a></p>
</li>
<li id="fn-3">
<p>Since I've only recently started studying web design, other alternatives don't readily come to mind yet. I plan to continue exploring ‘effective typography in digital environments’ going forward. <a href="#fr-3-1">↩</a></p>
</li>
<li id="fn-4">
<p>CJK is a typography term grouping the character environments of China, Japan, and Korea. In Western contexts, it is sometimes called East Asian Typography. However, since this encompasses too broad a geographical scope, translating it as <em>Northeast Asia</em> or <em>the Sinitic cultural sphere</em> would be more appropriate. But even this isn't entirely accurate. This is because CJK is closer to being a proper noun denoting the writing systems of China, Japan, and Korea. Therefore, this document will retain the term CJK without translation, despite its less intuitive meaning, as it is the more accurate term. <a href="#fr-4-1">↩</a></p>
</li>
<li id="fn-5">
<p>In this document, <em>writing conventions</em> is used as a broad term encompassing “the overall customs and styles of writing”. The term <em>writing system</em> was considered but avoided as it corresponds to the typography term <em>Writing System</em>. <em>Writing System</em> refers to the character system at the language level, such as alphabets or kana. <a href="#fr-5-1">↩</a></p>
</li>
<li id="fn-6">
<p>Fonts like Noto Sans and Sandoll Gothic all have a horizontal width narrower than their vertical height. Consequently, the <a href="/works/project/pr-005/">JH Web Duo</a> based on Noto Sans also uses a rectangular unit, not a square, as its full-width character standard. <a href="#fr-6-1">↩</a></p>
</li>
</ol>
</section>


  </div>

</article>

<div id="image-viewer" aria-hidden="true">
  <button class="viewer-close" aria-label="Close">×</button>
  <button class="viewer-prev" aria-label="Previous">←</button>
  <img class="viewer-image" alt="" />
  <button class="viewer-next" aria-label="Next">→</button>
</div>


<script>
  (function () {
  
    function isVisible(el) {
      return !!(el && el.offsetParent !== null);
    }
  
    function isInViewport(el) {
      if (!el) return false;
      const r = el.getBoundingClientRect();
      return r.bottom > 0 && r.top < window.innerHeight;
    }
  
    function scrollToRef(el, block) {
      if (!el) return;
      el.scrollIntoView({
        behavior: "smooth",
        block: block
      });
    }
  
    function scrollDocumentToRevealMeta() {
      window.scrollTo({
        top: document.documentElement.scrollHeight,
        behavior: "smooth"
      });
    }
  
    function setActiveFootnote(id) {
      history.pushState(null, "", "#" + id);
  
      document.querySelectorAll(".meta-note").forEach(el => {
        el.classList.toggle("is-active", el.dataset.fnid === id);
      });
  
      document.querySelectorAll(".footnotes-list li[id]").forEach(el => {
        el.classList.toggle("is-active", el.id === id);
      });
    }
  
    const mqDesktop = window.matchMedia("(min-width: 600px)");
  
    document.addEventListener("click", function (e) {
  
      const meta = e.target.closest(".meta-note[data-fnid]");
      if (meta) {
        if (e.target.closest("a")) return;
  
        const id = meta.dataset.fnid;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const def = e.target.closest(".footnotes-list li[id]");
      if (def) {
        if (e.target.closest("a")) return;
  
        const id = def.id;
        if (!id) return;
  
        const ref = document.querySelector(
          '.footnote-reference a[href="#' + id + '"]'
        );
        if (!ref) return;
  
        scrollToRef(ref, "start");
        setActiveFootnote(id);
        return;
      }
  
      const refLink = e.target.closest(".footnote-reference a[href^='#']");
      if (!refLink) return;
  
      e.preventDefault();
  
      const id = refLink.getAttribute("href").slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
  
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
    document.addEventListener("DOMContentLoaded", function () {
      if (!location.hash.startsWith("#")) return;
  
      const id = location.hash.slice(1);
      if (!id) return;
  
      setActiveFootnote(id);
  
      if (mqDesktop.matches) {
        const metaTarget = document.querySelector(
          ".meta-note[data-fnid='" + id + "']"
        );
        if (metaTarget && isVisible(metaTarget)) {
          if (!isInViewport(metaTarget)) {
            scrollDocumentToRevealMeta(metaTarget);
          }
          return;
        }
      }
  
      const footTarget = document.getElementById(id);
      if (footTarget && isVisible(footTarget)) {
        scrollToRef(footTarget, "end");
      }
    });
  
  })();
  </script>  
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const PUNCTS = `"'\u2018\u201C([{‹«〈《「『`;
    
        const targets = document.querySelectorAll(
  '.page-meta .meta-title, \
   .page-meta .meta-line, \
   .page-body .page-content p, \
   .page-body .page-content li'
);

    
      targets.forEach(el => {
        const text = (el.textContent || '').trimStart();
        if (!text) return;
    
        const firstChar = text[0];
        if (!PUNCTS.includes(firstChar)) return;
    
        el.classList.add('hang-punct');
      });
    });
    </script>
    
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const superscriptMap = {
          "0": "⁰",
          "1": "¹",
          "2": "²",
          "3": "³",
          "4": "⁴",
          "5": "⁵",
          "6": "⁶",
          "7": "⁷",
          "8": "⁸",
          "9": "⁹"
        };
      
        document
          .querySelectorAll("sup.footnote-reference a")
          .forEach(el => {
            const text = el.textContent.trim();
      
            if (!/^\d+$/.test(text)) return;
      
            const superscript = [...text]
              .map(d => superscriptMap[d] || d)
              .join("");
      
            el.textContent = superscript;
            el.setAttribute("aria-label", `Footnote ${text}`);
          });
      });
      </script>
      
      <script>
        (function () {
          const root = document.querySelector(".page-body.page-content");
          if (!root) return;

          root.querySelectorAll("blockquote ol > li").forEach(li => {
            if (li.querySelector(":scope > .li-body")) return;

            const body = document.createElement("span");
            body.className = "li-body";

            const nodes = Array.from(li.childNodes);

            nodes.forEach(node => {
              if (
                node.nodeType === Node.ELEMENT_NODE ||
                (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "")
              ) {
                body.appendChild(node);
              }
            });

            li.appendChild(body);
          });
        })();
        </script>


        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const root = document.querySelector(".page-body.page-content");
            if (!root) return;
          
            root.querySelectorAll("p > strong").forEach(strong => {
              const parent = strong.parentElement;
              if (parent && parent.classList.contains("centered-strong")) return;
          
              const wrapper = document.createElement("span");
              wrapper.className = "centered-strong";
          
              parent.replaceChild(wrapper, strong);
              wrapper.appendChild(strong);
            });
          });
          </script>
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const isMobile = window.matchMedia("(max-width: 600px)").matches;
    
      const images = Array.from(
        document.querySelectorAll(".page-body.page-content figure img")
      );
      if (!images.length) return;
    
      const viewer = document.getElementById("image-viewer");
      const viewerImg = viewer.querySelector(".viewer-image");
      const btnClose = viewer.querySelector(".viewer-close");
      const btnPrev = viewer.querySelector(".viewer-prev");
      const btnNext = viewer.querySelector(".viewer-next");
    
      let currentIndex = 0;
      let scrollY = 0;
    
      function lockScroll() {
        scrollY = window.scrollY;
        document.body.style.position = "fixed";
        document.body.style.top = `-${scrollY}px`;
        document.body.style.left = "0";
        document.body.style.right = "0";
        document.body.style.width = "100%";
      }
    
      function unlockScroll() {
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.left = "";
        document.body.style.right = "";
        document.body.style.width = "";
        window.scrollTo(0, scrollY);
      }
    
      function openViewer(index) {
        currentIndex = index;
        viewerImg.src = images[currentIndex].src;
        viewer.classList.add("is-open");
        viewer.setAttribute("aria-hidden", "false");
    
        if (isMobile) lockScroll();
      }
    
      function closeViewer() {
        viewer.classList.remove("is-open");
        viewer.setAttribute("aria-hidden", "true");
    
        if (isMobile) unlockScroll();
      }
    
      function prev() {
        if (currentIndex > 0) openViewer(currentIndex - 1);
      }
    
      function next() {
        if (currentIndex < images.length - 1) openViewer(currentIndex + 1);
      }
    
      images.forEach((img, i) => {
        img.style.cursor = "zoom-in";
        img.addEventListener("click", () => openViewer(i));
      });
    

      if (!isMobile) {
        btnClose.addEventListener("click", closeViewer);
        btnPrev.addEventListener("click", prev);
        btnNext.addEventListener("click", next);
    
        viewerImg.addEventListener("click", closeViewer);
        viewer.addEventListener("click", e => {
          if (e.target === viewer) closeViewer();
        });
      }
    
      if (isMobile) {
        viewer.addEventListener("click", closeViewer);
    
        let startX = 0;
        let startY = 0;
    
        viewer.addEventListener(
          "touchstart",
          e => {
            const t = e.touches[0];
            startX = t.clientX;
            startY = t.clientY;
          },
          { passive: true }
        );
    
        viewer.addEventListener("touchend", e => {
          const t = e.changedTouches[0];
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
    
          if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
            dx > 0 ? prev() : next();
          }
        });
      }
    
      document.addEventListener("keydown", e => {
        if (!viewer.classList.contains("is-open")) return;
    
        if (e.key === "Escape") closeViewer();
        if (e.key === "ArrowLeft") prev();
        if (e.key === "ArrowRight") next();
      });
    });
    </script>
    

    <script>
      (function () {
        if (!window.matchMedia("(min-width: 601px)").matches) return;
    
        const preview = document.createElement("div");
        preview.id = "link-preview";
        document.body.appendChild(preview);
    
        let aborter = null;
    
        function isHomeLink(a) {
          if (!a || !a.href) return false;
          try {
            const url = new URL(a.href);
            if (url.origin !== location.origin) return false;
            return url.pathname === "/" || url.pathname === "/kr/";
          } catch {
            return false;
          }
        }
    
        function isInternalLink(a) {
          if (!a || !a.href) return false;
          try {
            return new URL(a.href).origin === location.origin;
          } catch {
            return false;
          }
        }
    
        function extractPreviewText(html) {
          const doc = new DOMParser().parseFromString(html, "text/html");
          const body = doc.querySelector(".page-body");
          if (!body) return "";
    
          body.querySelectorAll(
            "figure, img, pre, code, table, script, style, .footnotes, .footnotes-list, aside"
          ).forEach(el => el.remove());
    
          body.querySelectorAll("sup").forEach(el => el.remove());
    
          const candidates = Array.from(body.querySelectorAll("p, li"))
            .map(el => el.textContent.replace(/\s+/g, " ").trim())
            .filter(text => text.length > 0);
    
          return candidates[0] || "";
        }
    
        function positionPreview(e) {
          const offset = 14;
          const maxX = window.innerWidth - preview.offsetWidth - 8;
          const maxY = window.innerHeight - preview.offsetHeight - 8;
    
          preview.style.left = Math.min(e.clientX + offset, maxX) + "px";
          preview.style.top = Math.min(e.clientY + offset, maxY) + "px";
        }
    
        document.addEventListener("mouseover", async (e) => {
          const a = e.target.closest("a[href]");
          if (!a) return;
          if (a.closest("header")) return;
          if (a.closest("sup")) return;
    
          aborter?.abort();
          aborter = new AbortController();
    
          if (isHomeLink(a) && a.closest(".page-two-col")) {
            preview.textContent = sessionStorage.getItem("jh_site_title") || "J—H";
            preview.classList.add("is-visible");
            positionPreview(e);
            return;
          }
    
          if (!isInternalLink(a) || !a.closest(".page-two-col")) return;
    
          try {
            const res = await fetch(a.href, { signal: aborter.signal });
            const html = await res.text();
            const text = extractPreviewText(html);
            if (!text) return;
    
            preview.textContent = text;
            preview.classList.add("is-visible");
            positionPreview(e);
          } catch {}
        });
    
        document.addEventListener("mousemove", (e) => {
          if (!preview.classList.contains("is-visible")) return;
          positionPreview(e);
        });
    
        document.addEventListener("mouseout", (e) => {
          const a = e.target.closest("a[href]");
          if (!a) return;

          if (a.contains(e.relatedTarget)) return;

          preview.classList.remove("is-visible");
          aborter?.abort();
        });

      })();
    </script>
    




    </main>

<footer class="footer" role="contentinfo">
  <p class="footer__text">
    © 2026 <span id="footer-site-title"></span><span class="footer-sep"></span>
    
      <span class="footer-msg">This website is <span id="footer-variant">(for a while)</span> in the making.</span>
    
  </p>

</footer>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("menu-toggle");
    const menu = document.getElementById("global-menu");
    if (!btn || !menu) return;

    const openMenu = () => {
      menu.hidden = false;
      btn.setAttribute("aria-expanded", "true");
      document.body.classList.add("menu-open");
    };

    const closeMenu = () => {
      menu.hidden = true;
      btn.setAttribute("aria-expanded", "false");
      document.body.classList.remove("menu-open");
    };

    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const expanded = btn.getAttribute("aria-expanded") === "true";
      expanded ? closeMenu() : openMenu();
    });

    document.addEventListener("click", (e) => {
      if (!menu.contains(e.target) && !btn.contains(e.target)) {
        closeMenu();
      }
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeMenu();
    });
  });
</script>


    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const currentHost = window.location.hostname;
        document
          .querySelectorAll('a[href^="http"]')
          .forEach(link => {
            const url = new URL(link.href);
            if (url.hostname !== currentHost) {
              link.setAttribute("target", "_blank");
              link.setAttribute("rel", "noopener noreferrer");
            }
          });
      });
    </script>


<script>
  const SITE_TITLES = [
    "J—H",
    "j—h",
    "Jaydashaitch",
    "제이대시에이치",
    "제이(대시)에이치",
    "JAY(DASH)AITCH",
    "JH ARCHIVE",
    "JAEHYEON LEE",
    "JAE—HYEON",
    "jay—aitch",
    "JAE(DASH)HYEON"
  ];
  
  function pickRandom(list) {
    return list[Math.floor(Math.random() * list.length)];
  }
  
  function pickRandomDifferent(list, current) {
    const pool = list.filter(item => item !== current);
    return pool.length
      ? pool[Math.floor(Math.random() * pool.length)]
      : current;
  }
  
  (function () {
    const titleEl = document.getElementById("site-title");
    const footerEl = document.getElementById("footer-site-title");
    if (!titleEl || !footerEl) return;
  
    const KEY = "jh_site_title";
  
    const renderTitle = (el, text) => {
      el.innerHTML = "";
      [...text].forEach(char => {
        const span = document.createElement("span");
        span.textContent = char;
        el.appendChild(span);
      });
    };
  
    if (!sessionStorage.getItem(KEY)) {
      sessionStorage.setItem(KEY, pickRandom(SITE_TITLES));
    }
  
    const initial = sessionStorage.getItem(KEY);
    renderTitle(titleEl, initial);
    footerEl.textContent = initial;
  
    titleEl.addEventListener("click", (e) => {
      e.preventDefault();
  
      const IS_HOME =
        window.location.pathname === "/" ||
        window.location.pathname === "/kr/";
  
      if (!IS_HOME) {
        window.location.href = titleEl.href;
        return;
      }
  
      const current = sessionStorage.getItem(KEY);
      const next = pickRandomDifferent(SITE_TITLES, current);
      sessionStorage.setItem(KEY, next);
  
      const layer = document.createElement("div");
      layer.className = "falling-layer";
      document.body.appendChild(layer);
  
      [...titleEl.children].forEach(originalSpan => {
        const rect = originalSpan.getBoundingClientRect();
  
        const span = document.createElement("span");
        span.className = "falling-char";
        span.textContent = originalSpan.textContent;
  
        span.style.left = `${rect.left}px`;
        span.style.top = `${rect.top}px`;
        span.style.animationDelay = `${Math.random() * 0.15}s`;
        span.style.animationDuration = `${1.2 + Math.random() * 1.6}s`;
  
        layer.appendChild(span);
      });
  
      titleEl.classList.add("is-switching");
  
      renderTitle(titleEl, next);
      footerEl.textContent = next;
  
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          titleEl.classList.remove("is-switching");
        });
      });
  
      setTimeout(() => {
        layer.remove();
      }, 2000);
    });
  })();
</script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const target = document.getElementById("footer-variant");
        if (!target) return;
      
        const lang = document.documentElement.lang;
      
        const variants = lang === "ko"
          ? [
              "(한동안은)",
              "(당분간은)",
              "(얼마간은)",
              "(현재로서는)",
              "(일단은)",
              "(우선은)",
              "(잠시나마)",
              "(당장까지는)",
              "(지금으로서는)",
              "(일정 기간동안은)",
              "(잠정적으로)",
              "(잠시 동안은)",
              "(지금은 계속)"
            ]
          : [
              "(for a while)",
              "(for now)",
              "(for the time being)",
              "(temporarily)",
              "(for the moment)",
              "(in the meantime)",
              "(for some time)",
              "(briefly)",
              "(until further notice)",
              "(as of now)",
              "(for a certain period)",
              "(still)",
              "(for a short while)"
            ];
      
        let current = target.textContent;
      
        const pickNext = () => {
          let next;
          do {
            next = variants[Math.floor(Math.random() * variants.length)];
          } while (next === current);
      
          current = next;
          target.textContent = next;
        };
      
        setInterval(pickNext, 1000);
      });
      </script>
  
  <script>
    (function () {
    
      const tooltip = document.createElement("div");
      tooltip.id = "menu-tooltip";
      document.body.appendChild(tooltip);
    
      const canHover = window.matchMedia("(hover: hover)").matches;
    
      function position(x, y) {
        const offset = 6;
    
        tooltip.style.left = x + offset + "px";
        tooltip.style.top = y + "px";
    
        tooltip.style.height = "";
        tooltip.style.lineHeight = "";
    
        tooltip.style.bottom = "";
        tooltip.style.transform = "";
      }
    
      function show(message, x, y) {
        tooltip.textContent = message;
        tooltip.classList.add("is-visible");
    
        position(x, y);
    
        if (!canHover) {
          clearTimeout(tooltip._timer);
    
          tooltip._timer = setTimeout(() => {
            tooltip.classList.remove("is-visible");
          }, 900);
        }
      }
    
      function getTextRect(el) {
        const range = document.createRange();
        range.selectNodeContents(el);
        return range.getBoundingClientRect();
      }
    
      if (canHover) {
    
        document.addEventListener("mouseover", (e) => {
    
          const disabled = e.target.closest(".menu-item--disabled");
          if (!disabled) return;
    
          const lang = document.documentElement.lang;
    
          show(
            lang === "ko" ? "준비중..." : "Coming soon...",
            e.clientX,
            e.clientY
          );
    
        });
    
        document.addEventListener("mousemove", (e) => {
          if (!tooltip.classList.contains("is-visible")) return;
    
          position(e.clientX, e.clientY);
        });
    
        document.addEventListener("mouseout", (e) => {
          if (!e.target.closest(".menu-item--disabled")) return;
    
          tooltip.classList.remove("is-visible");
        });
    
      } else {
    
        document.addEventListener("touchstart", (e) => {
    
          const disabled = e.target.closest(".menu-item--disabled");
          if (!disabled) return;
    
          const lang = document.documentElement.lang;
          const rect = getTextRect(disabled);
    
          show(
            lang === "ko" ? "준비중..." : "Coming soon...",
            rect.right,
            rect.top
          );
    
        });
    
      }
    
    })();
    </script>


  </body>
</html>
